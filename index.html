<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Prevent crawling/indexing -->
    <meta name="robots" content="noindex, nofollow">

    <!-- Address Bar / Theme Colors -->
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Roberts Cup">

    <title>2025-26 Roberts Cup</title>

    <!-- Local Icons from /images/web directory -->
    <link rel="icon" href="images/web/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="192x192" href="images/web/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="images/web/icon-512.png">
    <link rel="apple-touch-icon" href="images/web/apple-touch-icon.png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tailwind Config to Enforce Global Fonts -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Chivo', 'sans-serif'],
                        serif: ['"Patua One"', 'serif'],
                    },
                    colors: {
                        brand: '#0f172a', // Dark Slate
                    }
                }
            }
        }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Chivo:ital,wght@0,300;0,400;0,700;0,900;1,400&family=Patua+One&display=swap" rel="stylesheet">

    <style>
        /* PAGE MODE: Allow natural vertical scrolling */
        body {
            font-family: 'Chivo', sans-serif;
            /* Force the "overscroll" background to match the header color */
            background-color: #0f172a;
        }

        /* Ensure the app container covers the dark body with the light theme */
        #root > div {
            background-color: #f8fafc; /* Slate-50 */
            min-height: 100vh;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Patua One', serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            height: 10px;
            width: 8px;
            background: transparent;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 8px;
            border: 2px solid #f1f5f9;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Hide scrollbar for menu */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Sticky Column Shadow */
        .sticky-col-shadow {
            box-shadow: 4px 0 8px -4px rgba(0, 0, 0, 0.1);
        }

        /* Z-INDEX HIERARCHY */
        th.sticky-left { z-index: 50 !important; }
        td.sticky-left { z-index: 40 !important; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // --- CONFIGURATION ---
        const SCHEDULE_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR6DAHasgDxAIJfV8r9PnD7Y1Z2UqfwhQeFqnk_iMnQISf7dlvjgNiGYq6Bk6R7BPg8Ipm5AnNVjfGM/pub?gid=0&single=true&output=csv";
        const PICKS_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR6DAHasgDxAIJfV8r9PnD7Y1Z2UqfwhQeFqnk_iMnQISf7dlvjgNiGYq6Bk6R7BPg8Ipm5AnNVjfGM/pub?gid=1948765269&single=true&output=csv";
        const HISTORY_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR6DAHasgDxAIJfV8r9PnD7Y1Z2UqfwhQeFqnk_iMnQISf7dlvjgNiGYq6Bk6R7BPg8Ipm5AnNVjfGM/pub?gid=1391791324&single=true&output=csv";

        // --- HELPER: CSV PARSER ---
        const parseCSV = (text) => {
            const rows = [];
            let currentRow = [];
            let currentCell = '';
            let insideQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (char === '"') {
                    if (insideQuotes && nextChar === '"') {
                        currentCell += '"';
                        i++;
                    } else {
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    currentRow.push(currentCell.trim());
                    currentCell = '';
                } else if ((char === '\r' || char === '\n') && !insideQuotes) {
                    if (char === '\r' && nextChar === '\n') i++;
                    currentRow.push(currentCell.trim());
                    if (currentRow.length > 0) rows.push(currentRow);
                    currentRow = [];
                    currentCell = '';
                } else {
                    currentCell += char;
                }
            }
            if (currentCell) currentRow.push(currentCell.trim());
            if (currentRow.length > 0) rows.push(currentRow);

            return rows;
        };

        const csvToJson = (csvText) => {
            const rows = parseCSV(csvText);
            const headers = rows[0];
            const data = rows.slice(1).map(row => {
                let obj = {};
                headers.forEach((header, index) => {
                    obj[header] = row[index] || "";
                });
                return obj;
            });
            return data;
        };

        // --- COMPONENTS ---

        const LoadingSpinner = ({ text }) => (
            <div className="flex flex-col items-center justify-center min-h-screen text-gray-500 bg-white">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-900 mb-4"></div>
                <p className="font-medium text-blue-900">{text}</p>
            </div>
        );

        const ErrorMessage = ({ message }) => (
            <div className="flex items-center justify-center min-h-screen bg-gray-100">
                <div className="bg-white border-l-4 border-red-500 text-red-700 px-6 py-4 rounded shadow-md max-w-lg">
                    <h3 className="font-bold mb-1">Data Error</h3>
                    <p className="text-sm">{message}</p>
                </div>
            </div>
        );

        const StatusPill = ({ pick, winner }) => {
            const safePick = pick ? pick.toString().trim() : "";
            const safeWinner = winner ? winner.toString().trim() : "";

            if (!safePick) {
                return <span className="text-gray-300">-</span>;
            }

            // Pending Game
            if (!safeWinner) {
                return (
                    <span className="inline-block px-2 py-0.5 rounded-lg border border-transparent text-xs font-medium bg-gray-50 text-gray-900 whitespace-nowrap">
                        {safePick}
                    </span>
                );
            }

            const isCorrect = safePick.toLowerCase() === safeWinner.toLowerCase();

            if (isCorrect) {
                return (
                    <span className="inline-flex items-center justify-center gap-1 px-2 py-0.5 rounded-lg border border-green-200 text-xs font-bold bg-green-100 text-green-800 whitespace-nowrap shadow-sm">
                        {safePick}
                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="3">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </span>
                );
            } else {
                return (
                    <span className="inline-block px-2 py-0.5 rounded-lg border border-transparent text-xs font-medium bg-red-50 text-red-400 line-through decoration-red-400 opacity-75 whitespace-nowrap">
                        {safePick}
                    </span>
                );
            }
        };

        // --- NAVIGATION ---
        const Navigation = ({ activeTab, setActiveTab }) => {
            const [isOpen, setIsOpen] = useState(false);

            const MENU_ITEMS = [
                { id: 'home', label: 'Home', icon: <><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></> },
                { id: 'standings', label: 'Standings', icon: <><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></> },
                { id: 'picks', label: 'Picks', icon: <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path> },
                { id: 'race', label: 'Race', icon: <><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></> },
                { id: 'badges', label: 'Badges', icon: <><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></> },
                { id: 'versus', label: 'Versus', icon: <><path d="M14.5 17.5L3 6V3h3l11.5 11.5"/><path d="M13 19l6-6"/><path d="M16 16l4 4"/><path d="M19 21l2-2"/></> },
                { id: 'simulator', label: 'Simulator', icon: <><circle cx="12" cy="10" r="8" /><path d="M12 6a4 4 0 0 1 4 4" /><path d="M8 22h8" /><path d="M12 18v4" /></> },
                { id: 'scouting', label: 'Scouting', icon: <><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></> },
                { id: 'history', label: 'History', icon: <><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></> }
            ];

            const handleNav = (id) => {
                setActiveTab(id);
                setIsOpen(false);
                window.scrollTo(0, 0);
            };

            return (
                <>
                    {/* Fixed Top Bar - Increased z-index to 100 */}
                    <div className="fixed top-0 left-0 right-0 h-16 bg-slate-900 z-[100] flex items-center justify-between px-4 shadow-lg border-b border-slate-800">
                        {/* Branding */}
                        <div className="flex items-center gap-2" onClick={() => handleNav('home')}>
                            <span className="text-2xl">üèÜ</span>
                            <span className="text-xl font-bold text-white font-serif tracking-tight">Roberts Cup</span>
                        </div>

                        {/* Hamburger Button */}
                        <button
                            onClick={() => setIsOpen(!isOpen)}
                            className="p-2 text-slate-300 hover:text-white transition-colors focus:outline-none"
                        >
                            {isOpen ? (
                                <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            ) : (
                                <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16m-7 6h7" />
                                </svg>
                            )}
                        </button>
                    </div>

                    {/* Dropdown Menu Overlay - Increased z-index to 90 to cover sticky headers */}
                    {isOpen && (
                        <div className="fixed inset-0 top-16 z-[90] bg-slate-900/95 backdrop-blur-sm overflow-y-auto">
                            <div className="flex flex-col p-4 gap-2 max-w-lg mx-auto">
                                {MENU_ITEMS.map((item) => (
                                    <button
                                        key={item.id}
                                        onClick={() => handleNav(item.id)}
                                        className={`flex items-center gap-4 p-4 rounded-xl transition-all ${
                                            activeTab === item.id
                                            ? "bg-blue-600 text-white shadow-lg ring-1 ring-blue-400"
                                            : "bg-slate-800 text-slate-300 hover:bg-slate-700 hover:text-white"
                                        }`}
                                    >
                                        <svg className="w-6 h-6 flex-shrink-0" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            {item.icon}
                                        </svg>
                                        <span className="text-lg font-bold">{item.label}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </>
            );
        };

        // --- PAGES ---

        // 0. HOME PAGE
        const HomePage = () => {
            const [headlines, setHeadlines] = useState([]);
            const [slateGames, setSlateGames] = useState([]);
            const [loading, setLoading] = useState(true);

            // Static Bank
            const STATIC_HEADLINES = [
                { type: "STATIC", Emoji: "üëÆ‚Äç‚ôÇÔ∏è", Headline: "League Office Update", Content: "The Commissioner has issued a formal warning: trash talk is mandatory, accuracy is optional." },
                { type: "STATIC", Emoji: "üìâ", Headline: "Market Crash", Content: "Confidence points are plummeting faster than crypto. Who bet the house on that 6-6 MAC team?" },
                { type: "STATIC", Emoji: "ü¶É", Headline: "Family Feud", Content: "Thanksgiving was weeks ago, but the real family drama is happening on the leaderboard right now." },
                { type: "STATIC", Emoji: "ü•∂", Headline: "Ice Cold", Content: "A chilly wind blows through the bottom of the standings. Better bundle up, it's freezing down there." },
                { type: "STATIC", Emoji: "üëÄ", Headline: "Sleeping Giant", Content: "They started slow, but the analytics (and their ego) say a comeback is statistically probable." },
                { type: "STATIC", Emoji: "ü•î", Headline: "Bowl SZN", Content: "Nothing says 'Happy Holidays' like sweating out a meaningless 4th quarter in the Famous Idaho Potato Bowl." },
                { type: "STATIC", Emoji: "üìä", Headline: "The Analytics", Content: "The numbers don't lie, but they might hurt your feelings. Check the probability charts if you dare." },
                { type: "STATIC", Emoji: "üëë", Headline: "Heavy is the Head", Content: "The leader looks comfortable, but the chasing pack is hungry. Can they hold the Iron Throne?" },
                { type: "STATIC", Emoji: "ü§î", Headline: "Questionable Call", Content: "That pick was... bold. Let's see if it pays off big or ends in total, hilarious tragedy." },
                { type: "STATIC", Emoji: "üöë", Headline: "Critical Condition", Content: "The elimination line is creeping closer. Time to make a move or start planning your concession speech." },
                { type: "STATIC", Emoji: "üé≤", Headline: "Rolling the Dice", Content: "High risk, high reward. Someone is swinging for the fences while everyone else plays it safe." },
                { type: "STATIC", Emoji: "üì∫", Headline: "Glued to the Screen", Content: "4 games, 3 screens, 1 champion. The remote control is the true MVP of the Roberts Cup." },
                { type: "STATIC", Emoji: "üíî", Headline: "Heartbreaker", Content: "That sure-thing lock just lost on a last-second field goal. There goes the perfect weekend." },
                { type: "STATIC", Emoji: "üìà", Headline: "Stock Rising", Content: "Moving up the leaderboard like a rocket. The dark horse has officially entered the chat." },
                { type: "STATIC", Emoji: "üîÆ", Headline: "Crystal Ball", Content: "Predicted the upset perfectly. Are they a football genius or a time traveler from 2026?" },
                { type: "STATIC", Emoji: "üßÇ", Headline: "Salty", Content: "The group chat is getting spicy. Rivalries are heating up as the games wind down." },
                { type: "STATIC", Emoji: "üèÜ", Headline: "Eye on the Prize", Content: "The Roberts Cup is gleaming. Polish your shelf, or prepare your excuses." },
                { type: "STATIC", Emoji: "üèπ", Headline: "Chaos Theory", Content: "Absolute mayhem in the late games. No lead is safe when the Pac-12 (RIP) plays after dark." },
                { type: "STATIC", Emoji: "üê¢", Headline: "Slow and Steady", Content: "Picking favorites might be boring, but it might just win the race. Don't be a hero." },
                { type: "STATIC", Emoji: "ü¶Å", Headline: "King of the Jungle", Content: "A dominant performance so far. Is this the start of a dynasty, or a fluke?" },
                { type: "STATIC", Emoji: "üèöÔ∏è", Headline: "Rebuilding Year", Content: "\"I'm just playing for fun this year.\" ‚Äî Every loser, ever." },
                { type: "STATIC", Emoji: "‚ö°", Headline: "Shock the World", Content: "The pick nobody saw coming just cashed. The standings are in shambles." },
                { type: "STATIC", Emoji: "üéØ", Headline: "Bullseye", Content: "Precision picking. While others panic, the leader stays cool under pressure." },
                { type: "STATIC", Emoji: "üìâ", Headline: "Fading Fast", Content: "Started strong, now fading down the stretch. Can they stop the bleeding before it's too late?" },
                { type: "STATIC", Emoji: "üçø", Headline: "Get the Popcorn", Content: "The tiebreaker scenarios are getting wild. We might need a NASA supercomputer for this finish." }
            ];

            useEffect(() => {
                const generateData = async () => {
                    try {
                        const [scheduleRes, picksRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL)
                        ]);

                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();

                        const schedule = csvToJson(scheduleText);
                        const picks = csvToJson(picksText).filter(p => p.Name);

                        // 1. Process Schedule
                        const sortedSchedule = schedule
                            .filter(g => g.Date && g.Time)
                            .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));
                        const unplayedGames = sortedSchedule.filter(g => !g.Winner);

                        // 2. Identify "On The Slate" Games (Today & Tomorrow)
                        const today = new Date();
                        const tomorrow = new Date();
                        tomorrow.setDate(today.getDate() + 1);

                        const isMatch = (gameDateStr, targetDate) => {
                            const gd = new Date(gameDateStr);
                            return gd.getDate() === targetDate.getDate() &&
                                   gd.getMonth() === targetDate.getMonth() &&
                                   gd.getFullYear() === targetDate.getFullYear();
                        };

                        const slate = sortedSchedule.filter(g => {
                            const isToday = isMatch(g.Date, today);
                            const isTomorrow = isMatch(g.Date, tomorrow);
                            if (isToday) g.dayLabel = "TODAY";
                            if (isTomorrow) g.dayLabel = "TOMORROW";
                            return isToday || isTomorrow;
                        });
                        setSlateGames(slate);

                        // 3. Stats Calculation (Simulation)
                        const SIMULATIONS = 2000;
                        const playerSimWins = {};
                        picks.forEach(p => playerSimWins[p.Name] = 0);

                        for (let i = 0; i < SIMULATIONS; i++) {
                            const simOutcomes = {};
                            unplayedGames.forEach(g => {
                                simOutcomes[g.Bowl] = Math.random() < 0.5 ? g["Team 1"] : g["Team 2"];
                            });
                            let maxWins = -1;
                            const currentSimScores = {};
                            picks.forEach(player => {
                                let sWins = 0;
                                sortedSchedule.forEach(g => {
                                    const pick = player[g.Bowl];
                                    let winner = g.Winner || simOutcomes[g.Bowl];
                                    if (pick && winner && pick.toLowerCase() === winner.toLowerCase()) sWins++;
                                });
                                currentSimScores[player.Name] = sWins;
                                if (sWins > maxWins) maxWins = sWins;
                            });
                            picks.forEach(player => {
                                if (currentSimScores[player.Name] === maxWins) playerSimWins[player.Name]++;
                            });
                        }

                        let stats = picks.map(player => {
                            let wins = 0; let losses = 0; let currentStreak = 0; let tempWinStreak = 0; let maxWinStreak = 0;
                            sortedSchedule.forEach(game => {
                                const winner = game.Winner;
                                const pick = player[game.Bowl];
                                if (winner) {
                                    if (pick && pick.toLowerCase() === winner.toLowerCase()) {
                                        wins++;
                                        currentStreak = currentStreak >= 0 ? currentStreak + 1 : 1;
                                        tempWinStreak++;
                                        if (tempWinStreak > maxWinStreak) maxWinStreak = tempWinStreak;
                                    } else {
                                        losses++;
                                        currentStreak = currentStreak <= 0 ? currentStreak - 1 : -1;
                                        tempWinStreak = 0;
                                    }
                                }
                            });
                            const winProb = (playerSimWins[player.Name] / SIMULATIONS * 100);
                            return {
                                name: player.Name, wins, losses, currentStreak, maxWinStreak, winProb,
                                rawPicks: player, champPick: player["National Championship"], tiebreaker: parseInt(player["Tiebreaker Score"] || 0)
                            };
                        });

                        stats.sort((a, b) => b.wins - a.wins);
                        const leader = stats[0];

                        // Calculate Swing Games for headlines
                        stats = stats.map(player => {
                            let swingGames = 0;
                            if (player.name !== leader.name) {
                                sortedSchedule.forEach(game => {
                                    if (!game.Winner) {
                                        const lp = leader.rawPicks[game.Bowl];
                                        const pp = player.rawPicks[game.Bowl];
                                        if (lp && pp && lp !== pp) swingGames++;
                                    }
                                });
                            }
                            return { ...player, swingGames };
                        });

                        // 4. Generate Dynamic Headlines
                        const dynamicPool = new Map();
                        const addHl = (key, data) => { if (!dynamicPool.has(key)) dynamicPool.set(key, data); };

                        // Simulation Odds HL
                        const highestProb = stats.reduce((prev, current) => (prev.winProb > current.winProb) ? prev : current);
                        if (highestProb && highestProb.winProb > 0) {
                            addHl("simulation", { Emoji: "ü§ñ", Headline: "Simulation Says...", Content: `The supercomputer is crushing on ${highestProb.name}, giving them a ${highestProb.winProb.toFixed(1)}% chance to take the crown. Do you trust the machine?` });
                        }

                        // Streaks HL
                        const heaters = stats.filter(p => p.currentStreak > 3).sort((a,b) => b.currentStreak - a.currentStreak);
                        if (heaters.length > 0) {
                            addHl("heater", { Emoji: "üî•", Headline: "Heater Alert", Content: `${heaters[0].name} has rattled off ${heaters[0].currentStreak} straight wins. Someone get a fire extinguisher.` });
                        }

                        // Miracles HL
                        const miraclePlayer = stats.find(p => p.winProb > 0 && p.winProb < 1);
                        if (miraclePlayer) {
                            addHl("miracle", { Emoji: "üé∞", Headline: "So You're Saying There's a Chance", Content: `${miraclePlayer.name} is holding onto a thread with a ${miraclePlayer.winProb.toFixed(1)}% win probability.` });
                        }

                        // Against the Grain HL
                        const rebel = stats.reduce((prev, current) => (prev.swingGames > current.swingGames) ? prev : current);
                        if (rebel && rebel.swingGames > 0) {
                            addHl("rebel", { Emoji: "üåæ", Headline: "Against the Grain", Content: `${rebel.name} has gone rogue with ${rebel.swingGames} picks different from the leader. Playing their own game.` });
                        }

                        // Mirror HL
                        if (stats.length > 1 && (stats[0].wins - stats[1].wins) === 1) {
                            addHl("mirror", { Emoji: "üëÄ", Headline: "Rearview Mirror", Content: `Objects in mirror are closer than they appear. ${stats[0].name} is clinging to a narrow 1-game lead over ${stats[1].name}.` });
                        }

                        // Tiebreaker HL
                        const moon = stats.reduce((prev, current) => (prev.tiebreaker > current.tiebreaker) ? prev : current);
                        if (moon && moon.tiebreaker > 0) {
                            addHl("moon", { Emoji: "üöÄ", Headline: "To The Moon", Content: `${moon.name} is predicting a massive ${moon.tiebreaker} points in the title game shootout.` });
                        }

                        // Final Headlines Selection
                        const dynamicHls = Array.from(dynamicPool.values());
                        const shuffledDynamic = dynamicHls.sort(() => 0.5 - Math.random());
                        const shuffledStatic = [...STATIC_HEADLINES].sort(() => 0.5 - Math.random());

                        let finalHeadlines = [];
                        finalHeadlines.push(shuffledStatic[0]);
                        const dCount = Math.min(shuffledDynamic.length, 5);
                        finalHeadlines.push(...shuffledDynamic.slice(0, dCount));

                        if (finalHeadlines.length < 6) {
                            const needed = 6 - finalHeadlines.length;
                            finalHeadlines.push(...shuffledStatic.slice(1, 1 + needed));
                        }
                        finalHeadlines.sort(() => 0.5 - Math.random());

                        setHeadlines(finalHeadlines);
                        setLoading(false);

                    } catch (err) {
                        console.error(err);
                        setLoading(false);
                    }
                };

                generateData();
            }, []);

            if (loading) return <LoadingSpinner text="Loading your home experience..." />;

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    {/* Grand Header */}
                    <div className="bg-slate-900 text-white p-8 md:p-12 rounded-b-3xl shadow-2xl mb-8 relative overflow-hidden border-b-4 border-yellow-500 pb-16">
                        <div className="absolute top-0 right-0 w-80 h-80 bg-gradient-to-br from-yellow-500/20 to-amber-600/10 rounded-full blur-3xl -mr-24 -mt-24 pointer-events-none"></div>
                        <div className="absolute bottom-0 left-0 w-64 h-64 bg-slate-800/50 rounded-full blur-3xl -ml-20 -mb-20 pointer-events-none"></div>

                        <div className="relative z-10 flex flex-col md:flex-row items-center justify-between gap-6 text-center md:text-left">
                            <div>
                                <div className="flex items-center justify-center md:justify-start gap-3 mb-3">
                                    <span className="bg-slate-800 text-yellow-400 px-3 py-1 rounded-full text-xs font-bold border border-yellow-500/30 uppercase tracking-widest shadow-sm">
                                        2025-26 Season
                                    </span>
                                </div>
                                <h1 className="text-5xl md:text-6xl font-black mb-2 tracking-tight">
                                    <span className="text-transparent bg-clip-text bg-gradient-to-br from-yellow-200 via-yellow-400 to-amber-500 drop-shadow-sm">
                                        Roberts Cup
                                    </span>
                                </h1>
                                <p className="text-slate-400 text-lg font-medium">The quest for family glory begins.</p>
                            </div>

                            <div className="relative mt-2 md:mt-0 group">
                                <div className="absolute inset-0 bg-yellow-400 blur-[40px] opacity-10 rounded-full group-hover:opacity-20 transition-opacity duration-700"></div>
                                <svg width="90" height="90" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-yellow-400 drop-shadow-[0_0_25px_rgba(250,204,21,0.4)] relative z-10">
                                    <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
                                </svg>
                            </div>
                        </div>
                    </div>

                    {/* Top Headlines Section */}
                    <div className="px-4 max-w-4xl mx-auto w-full relative z-20 pb-8">
                        <h2 className="text-2xl font-bold text-gray-900 font-serif mb-4 ml-1">Top Headlines</h2>
                         <div className="bg-white rounded-xl shadow-2xl border border-gray-100 overflow-hidden">
                            <div className="divide-y divide-gray-100">
                                {headlines.map((item, idx) => (
                                    <div key={idx} className="flex flex-col gap-1 p-5 hover:bg-blue-50/30 transition-colors group">
                                        <div className="flex items-center gap-3 mb-1">
                                            <span className="text-2xl flex-shrink-0">{item.Emoji}</span>
                                            <h4 className="font-bold text-gray-900 text-lg leading-tight group-hover:text-blue-900 transition-colors">{item.Headline}</h4>
                                        </div>
                                        <p className="text-gray-600 text-sm leading-relaxed">{item.Content}</p>
                                    </div>
                                ))}
                            </div>
                         </div>
                    </div>

                    {/* On The Slate Section */}
                    <div className="px-4 max-w-4xl mx-auto w-full relative z-20 pb-12">
                        <h2 className="text-2xl font-bold text-gray-900 font-serif mb-4 ml-1">On The Slate</h2>
                        {slateGames.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {slateGames.map((game, idx) => (
                                    <div key={idx} className="bg-white p-5 rounded-xl shadow-xl border border-gray-100 flex flex-col justify-between hover:shadow-2xl transition-shadow group">
                                        <div>
                                            <div className="flex justify-between items-start mb-3">
                                                {game.dayLabel === "TODAY" ? (
                                                    <span className="text-[10px] font-black text-green-700 uppercase tracking-widest bg-green-50 px-2 py-0.5 rounded border border-green-200">
                                                        TODAY
                                                    </span>
                                                ) : (
                                                    <span className="text-[10px] font-black text-blue-600 uppercase tracking-widest bg-blue-50 px-2 py-0.5 rounded border border-blue-100">
                                                        TOMORROW
                                                    </span>
                                                )}
                                                <span className="text-[10px] font-bold text-gray-400 uppercase">
                                                    {game.Date}
                                                </span>
                                            </div>
                                            <div className="mb-2">
                                                <div className="text-lg font-black text-gray-800 leading-tight">
                                                    {game["Team 1"]} <span className="text-gray-300 font-normal mx-1">vs</span> {game["Team 2"]}
                                                </div>
                                            </div>
                                            <div className="mb-2 text-xs font-bold text-gray-500 uppercase tracking-wider">
                                                {game.Bowl}
                                            </div>
                                        </div>
                                        <div className="flex items-center justify-between pt-3 border-t border-gray-50 mt-2">
                                            <div className="flex items-center gap-1.5 text-gray-500">
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                                </svg>
                                                <span className="text-xs font-bold">{game.Time}</span>
                                            </div>
                                            <div className="flex items-center gap-1.5 text-gray-500">
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                                </svg>
                                                <span className="text-xs font-bold uppercase tracking-tighter">{game.Network}</span>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="bg-gray-50 border-2 border-dashed border-gray-200 rounded-xl p-10 text-center">
                                <p className="text-gray-500 font-medium">
                                    No games found in the next two days. <br />
                                    <span className="text-sm font-normal">Check the Picks page for the next available matchup.</span>
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // 1. STANDINGS PAGE
        const StandingsPage = () => {
            const [standings, setStandings] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [sortConfig, setSortConfig] = useState({ key: 'wins', direction: 'descending' });

            useEffect(() => {
                const calculateStandings = async () => {
                    try {
                        const [scheduleRes, picksRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL)
                        ]);
                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();
                        const schedule = csvToJson(scheduleText);
                        const picks = csvToJson(picksText).filter(p => p.Name);
                        const sortedSchedule = schedule.filter(g => g.Date && g.Time).sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));
                        const unplayedGames = sortedSchedule.filter(g => !g.Winner);
                        const SIMULATIONS = 2000;
                        const playerSimWins = {};
                        picks.forEach(p => playerSimWins[p.Name] = 0);
                        for (let i = 0; i < SIMULATIONS; i++) {
                            const simOutcomes = {};
                            unplayedGames.forEach(g => { simOutcomes[g.Bowl] = Math.random() < 0.5 ? g["Team 1"] : g["Team 2"]; });
                            let maxWins = -1;
                            const currentSimScores = {};
                            picks.forEach(player => {
                                let sWins = 0;
                                sortedSchedule.forEach(g => {
                                    const pick = player[g.Bowl];
                                    let winner = g.Winner || simOutcomes[g.Bowl];
                                    if (pick && winner && pick.toLowerCase() === winner.toLowerCase()) sWins++;
                                });
                                currentSimScores[player.Name] = sWins;
                                if (sWins > maxWins) maxWins = sWins;
                            });
                            picks.forEach(player => { if (currentSimScores[player.Name] === maxWins) playerSimWins[player.Name]++; });
                        }
                        let stats = picks.map(player => {
                            let wins = 0; let losses = 0; let currentStreak = 0; let tempWinStreak = 0; let maxWinStreak = 0;
                            sortedSchedule.forEach(game => {
                                const winner = game.Winner;
                                const pick = player[game.Bowl];
                                if (winner) {
                                    if (pick && pick.toLowerCase() === winner.toLowerCase()) {
                                        wins++;
                                        currentStreak = currentStreak >= 0 ? currentStreak + 1 : 1;
                                        tempWinStreak++;
                                        if (tempWinStreak > maxWinStreak) maxWinStreak = tempWinStreak;
                                    } else {
                                        losses++;
                                        currentStreak = currentStreak <= 0 ? currentStreak - 1 : -1;
                                        tempWinStreak = 0;
                                    }
                                }
                            });
                            const winProbVal = playerSimWins[player.Name];
                            const winProb = (winProbVal / SIMULATIONS * 100).toFixed(1) + '%';
                            return {
                                name: player.Name, wins, losses, percentage: (wins + losses > 0 ? (wins / (wins + losses)).toFixed(3) : ".000").replace('0.', '.'),
                                currentStreak, maxWinStreak, champPick: player["National Championship"] || "-",
                                tiebreaker: player["Tiebreaker Score"] || "0", rawPicks: player, winProb, winProbNum: winProbVal
                            };
                        });
                        stats.sort((a, b) => b.wins - a.wins);
                        const leader = stats[0];
                        let currentRank = 1;
                        for (let i = 0; i < stats.length; i++) {
                            if (i > 0 && stats[i].wins < stats[i - 1].wins) currentRank = i + 1;
                            stats[i].rank = currentRank;
                            const winDeficit = leader.wins - stats[i].wins;
                            let status = "alive";
                            if (stats[i].rank === 1) {
                                stats[i].swingGames = "-";
                                status = "leading";
                            } else {
                                let diffs = 0;
                                sortedSchedule.forEach(game => {
                                    if (!game.Winner) {
                                        const lp = leader.rawPicks[game.Bowl];
                                        const pp = stats[i].rawPicks[game.Bowl];
                                        if (lp && pp && lp !== pp) diffs++;
                                    }
                                });
                                stats[i].swingGames = diffs;
                                if (diffs < winDeficit) status = "eliminated";
                            }
                            stats[i].status = status;
                        }
                        setStandings(stats);
                    } catch (err) { console.error(err); setError(err.message); } finally { setLoading(false); }
                };
                calculateStandings();
            }, []);

            const sortedData = useMemo(() => {
                let sortableItems = [...standings];
                if (sortConfig !== null) {
                    sortableItems.sort((a, b) => {
                        let aValue = a[sortConfig.key];
                        let bValue = b[sortConfig.key];
                        if (['wins', 'losses', 'rank', 'currentStreak', 'maxWinStreak', 'swingGames', 'winProbNum'].includes(sortConfig.key)) {
                            if (sortConfig.key === 'swingGames') {
                                const aVal = aValue === '-' ? 999 : Number(aValue);
                                const bVal = bValue === '-' ? 999 : Number(bValue);
                                aValue = aVal; bValue = bVal;
                            } else { aValue = Number(aValue); bValue = Number(bValue); }
                        } else if (sortConfig.key === 'percentage') {
                            aValue = parseFloat(aValue); bValue = parseFloat(bValue);
                        } else if (sortConfig.key === 'champPick') {
                            const getSeed = (str) => {
                                const match = String(str).match(/#(\d+)/);
                                return match ? parseInt(match[1], 10) : 999;
                            };
                            const aSeed = getSeed(aValue);
                            const bSeed = getSeed(bValue);
                            if (aSeed !== bSeed) {
                                aValue = aSeed; bValue = bSeed;
                            } else {
                                aValue = String(aValue).toLowerCase(); bValue = String(bValue).toLowerCase();
                            }
                        } else if (sortConfig.key === 'tiebreaker') {
                            aValue = parseInt(aValue, 10) || 0; bValue = parseInt(bValue, 10) || 0;
                        } else if (sortConfig.key === 'status') {
                            const statusOrder = { 'leading': 3, 'alive': 2, 'eliminated': 1 };
                            aValue = statusOrder[aValue] || 0; bValue = statusOrder[bValue] || 0;
                        } else if (typeof aValue === 'string') {
                            aValue = aValue.toLowerCase(); bValue = bValue.toLowerCase();
                        }
                        if (aValue < bValue) return sortConfig.direction === 'ascending' ? -1 : 1;
                        if (aValue > bValue) return sortConfig.direction === 'ascending' ? 1 : -1;
                        return 0;
                    });
                }
                return sortableItems;
            }, [standings, sortConfig]);

            const requestSort = (key) => {
                let direction = 'ascending';
                if (['wins', 'percentage', 'currentStreak', 'maxWinStreak', 'swingGames', 'status', 'winProbNum'].includes(key)) direction = 'descending';
                if (sortConfig.key === key) direction = sortConfig.direction === 'ascending' ? 'descending' : 'ascending';
                setSortConfig({ key, direction });
            };

            const getSortIcon = (name) => {
                const activeKey = sortConfig.key === 'winProbNum' ? 'winProb' : sortConfig.key;
                if (activeKey !== name) return <span className="ml-1 text-gray-300 opacity-0 group-hover:opacity-50 text-[10px]">‚ñº</span>;
                return sortConfig.direction === 'ascending' ? <span className="ml-1 text-blue-600 text-[10px]">‚ñ≤</span> : <span className="ml-1 text-blue-600 text-[10px]">‚ñº</span>;
            };

            const renderRank = (rank) => {
                const s = ["th", "st", "nd", "rd"]; const v = rank % 100; const text = rank + (s[(v - 20) % 10] || s[v] || s[0]);
                if (rank === 1) return <span className="inline-block px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800 font-bold text-xs whitespace-nowrap">{text}</span>;
                if (rank === 2) return <span className="inline-block px-2 py-0.5 rounded-full bg-gray-100 text-gray-600 font-bold text-xs whitespace-nowrap">{text}</span>;
                if (rank === 3) return <span className="inline-block px-2 py-0.5 rounded-full bg-orange-100 text-orange-800 font-bold text-xs whitespace-nowrap">{text}</span>;
                return <span className="text-gray-900 text-sm">{text}</span>;
            };

            const renderStreak = (streak) => {
                if (streak === 0) return <span className="text-gray-400">-</span>;
                const isWin = streak > 0; const val = Math.abs(streak); const text = isWin ? `W${val}` : `L${val}`;
                let classes = "inline-flex items-center px-2 py-0.5 text-xs border ";
                let icon = null;
                if (isWin) {
                    if (val >= 5) { classes += "rounded-full font-bold bg-[#fb8c00] text-white border-orange-700"; icon = "üî•"; }
                    else if (val === 4) classes += "rounded-full font-bold bg-[#ffb74d] text-orange-900 border-orange-600";
                    else if (val === 3) classes += "rounded-full font-bold bg-[#ffe0b2] text-orange-800 border-orange-300";
                    else classes += "rounded-lg font-medium bg-gray-50 text-gray-900 border-transparent";
                } else {
                    if (val >= 5) { classes += "rounded-full font-bold bg-[#1e88e5] text-white border-blue-700"; icon = "‚ùÑÔ∏è"; }
                    else if (val === 4) classes += "rounded-full font-bold bg-[#64b5f6] text-blue-900 border-blue-600";
                    else if (val === 3) classes += "rounded-full font-bold bg-[#bbdefb] text-blue-800 border-blue-300";
                    else classes += "rounded-lg font-medium bg-gray-50 text-gray-900 border-transparent";
                }
                return <span className={classes}>{text} {icon && <span className="ml-1">{icon}</span>}</span>;
            };

            const renderStatus = (status) => {
                if (status === 'leading') return <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800 font-bold text-xs whitespace-nowrap">ü•á Leading</span>;
                if (status === 'eliminated') return <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-red-100 text-red-800 font-bold text-xs whitespace-nowrap">üíÄ Eliminated</span>;
                return <span className="inline-block px-2 py-0.5 rounded-full bg-green-100 text-green-800 font-bold text-xs whitespace-nowrap">Alive</span>;
            };

            if (loading) return <LoadingSpinner text="Loading Standings..." />;
            if (error) return <ErrorMessage message={error} />;

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-8 px-4"><div className="max-w-7xl mx-auto text-center"><h2 className="text-3xl text-blue-900 font-bold mb-1">Leaderboard</h2><p className="text-gray-600 text-sm">Who has the bragging rights?</p></div></div>
                    <div className="px-2 md:px-6 flex flex-col items-center">
                        <div className="w-full max-w-[98%] md:max-w-[90%] shadow-2xl border border-gray-100 rounded-xl bg-white overflow-hidden">
                            <div className="overflow-x-auto w-full">
                                <table className="min-w-max border-collapse w-full text-sm">
                                    <thead>
                                        <tr className="bg-gray-50 text-gray-800 cursor-pointer select-none">
                                            <th onClick={() => requestSort('name')} className="sticky left-0 sticky-left bg-gray-50 p-2 text-left font-bold border-r border-b border-gray-100 min-w-[140px] sticky-col-shadow group hover:bg-gray-100 transition-colors">Name {getSortIcon('name')}</th>
                                            <th onClick={() => requestSort('rank')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">Rank {getSortIcon('rank')}</th>
                                            <th onClick={() => requestSort('wins')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">Wins {getSortIcon('wins')}</th>
                                            <th onClick={() => requestSort('losses')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">Losses {getSortIcon('losses')}</th>
                                            <th onClick={() => requestSort('percentage')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">Percentage {getSortIcon('percentage')}</th>
                                            <th onClick={() => requestSort('currentStreak')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">üî• Current Streak {getSortIcon('currentStreak')}</th>
                                            <th onClick={() => requestSort('maxWinStreak')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">üí™ Longest Streak {getSortIcon('maxWinStreak')}</th>
                                            <th onClick={() => requestSort('champPick')} className="p-2 font-bold border-b border-gray-100 text-center min-w-[180px] group hover:bg-gray-100 transition-colors">üëë Championship Team {getSortIcon('champPick')}</th>
                                            <th onClick={() => requestSort('tiebreaker')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">üéØ Tiebreaker Score {getSortIcon('tiebreaker')}</th>
                                            <th onClick={() => requestSort('winProbNum')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">üîÆ Win Probability {getSortIcon('winProb')}</th>
                                            <th onClick={() => requestSort('status')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">üßÆ Elimination Status {getSortIcon('status')}</th>
                                            <th onClick={() => requestSort('swingGames')} className="p-2 font-bold border-b border-gray-100 text-center group hover:bg-gray-100 transition-colors">ü™ú Swing Games {getSortIcon('swingGames')}</th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white">
                                        {sortedData.map((player, idx) => (
                                            <tr key={idx} className="group hover:bg-blue-50 transition-colors border-b border-gray-100 last:border-0">
                                                <td className="sticky left-0 sticky-left p-2 text-left font-bold text-gray-900 border-r-2 border-gray-100 sticky-col-shadow bg-white">{player.name}</td>
                                                <td className="p-2 text-center border-r border-gray-100">{renderRank(player.rank)}</td>
                                                <td className="p-2 text-center text-gray-900 border-r border-gray-100">{player.wins}</td>
                                                <td className="p-2 text-center text-gray-600 border-r border-gray-100">{player.losses}</td>
                                                <td className="p-2 text-center text-gray-900 border-r border-gray-100">{player.percentage}</td>
                                                <td className="p-2 text-center border-r border-gray-100">{renderStreak(player.currentStreak)}</td>
                                                <td className="p-2 text-center border-r border-gray-100"><span className="inline-block px-2 py-0.5 rounded-lg border border-transparent text-xs font-medium bg-gray-50 text-gray-900">W{player.maxWinStreak}</span></td>
                                                <td className="p-2 text-center border-r border-gray-100 text-gray-900 truncate">{player.champPick}</td>
                                                <td className="p-2 text-center text-gray-900 border-r border-gray-100">{player.tiebreaker}</td>
                                                <td className="p-2 text-center text-gray-900 border-r border-gray-100">{player.winProb}</td>
                                                <td className="p-2 text-center border-r border-gray-100">{renderStatus(player.status)}</td>
                                                <td className="p-2 text-center text-gray-900">{player.swingGames}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div className="mt-8 px-2 md:px-6 flex flex-col items-center pb-10">
                        <div className="w-full max-w-[98%] md:max-w-[90%] shadow-2xl border border-gray-100 rounded-xl bg-white overflow-hidden">
                            <div className="px-4 py-3 border-b border-gray-100"><h3 className="text-lg font-bold text-gray-900 font-serif">Legend</h3></div>
                            <div className="p-4 space-y-4 text-sm text-gray-600">
                                <div className="space-y-1"><div className="flex gap-2 items-start"><span className="font-bold text-gray-900 whitespace-nowrap text-base">üîÆ Win Probability:</span></div><p className="mb-2">Based on 2,000 Monte Carlo simulations of the remaining games (treated as 50/50 coin flips).</p></div>
                                <div className="border-t border-gray-100 pt-3 space-y-1"><div className="flex gap-2 items-start"><span className="font-bold text-gray-900 whitespace-nowrap text-base">üßÆ Elimination Status:</span></div><p className="mb-2">Compares how many wins you‚Äôre behind the lead to your remaining swing chances.</p>
                                    <ul className="list-disc pl-5 space-y-1"><li><span className="font-bold text-yellow-700">Leading</span> ‚Äî currently in 1st place (or tied for it)</li><li><span className="font-bold text-green-700">Alive</span> ‚Äî mathematically possible to catch the leader</li><li><span className="font-bold text-red-700">Eliminated</span> ‚Äî not enough swing games remaining to overcome the deficit</li></ul>
                                </div>
                                <div className="border-t border-gray-100 pt-3 space-y-1">
                                    <div className="flex gap-2 items-start"><span className="font-bold text-gray-900 whitespace-nowrap text-base">ü™ú Swing Games:</span></div>
                                    <p className="mb-2">The number of remaining games where your pick differs from the current leader. You can only gain ground on the leader in these specific games. If this number is lower than your win deficit, you are eliminated.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 2. PICKS PAGE
        const PicksPage = () => {
            const [schedule, setSchedule] = useState([]); const [picks, setPicks] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null);
            useEffect(() => {
                const fetchData = async () => {
                    try {
                        const [scheduleResponse, picksResponse] = await Promise.all([fetch(SCHEDULE_URL), fetch(PICKS_URL)]);
                        if (!scheduleResponse.ok || !picksResponse.ok) throw new Error("Failed to fetch data from Google Sheets");
                        const scheduleText = await scheduleResponse.text(); const picksText = await picksResponse.text();
                        const parsedSchedule = csvToJson(scheduleText); const parsedPicks = csvToJson(picksText);
                        setSchedule(parsedSchedule.filter(g => g.Bowl && g.Date)); setPicks(parsedPicks.filter(p => p.Name));
                    } catch (err) { console.error(err); setError(err.message); } finally { setLoading(false); }
                };
                fetchData();
            }, []);
            if (loading) return <LoadingSpinner text="Loading Picks..." />;
            if (error) return <ErrorMessage message={error} />;
            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-8 px-4"><div className="max-w-7xl mx-auto text-center"><h2 className="text-3xl text-blue-900 font-bold mb-1">Bowl Mania</h2><p className="text-gray-600 text-sm">Every game, every prediction.</p></div></div>
                    <div className="px-2 md:px-6 flex flex-col items-center">
                        <div className="w-full max-w-[98%] md:max-w-[90%] shadow-2xl border border-gray-100 rounded-xl bg-white overflow-hidden">
                            <div className="overflow-x-auto w-full">
                                <table className="min-w-max border-collapse w-full text-sm">
                                    <thead>
                                        <tr className="bg-gray-50 text-gray-800">
                                            <th className="sticky left-0 sticky-left bg-gray-50 p-2 text-left font-bold border-r border-b border-gray-100 min-w-[140px] sticky-col-shadow tracking-wide text-sm shadow-sm">Name</th>
                                            {schedule.map((game, idx) => (
                                                <th key={idx} className="bg-gray-50 p-2 font-bold border-r border-b border-gray-100 whitespace-nowrap min-w-[220px] text-center shadow-sm">
                                                    <div className="flex flex-col gap-0.5"><span className="text-gray-900 text-[14px]">{game.Bowl}</span><span className="text-gray-500 text-[11px] font-normal">{game.Date} ‚Ä¢ {game.Time} ‚Ä¢ {game.Network}</span></div>
                                                </th>
                                            ))}
                                            <th className="bg-gray-50 p-2 font-bold border-b border-gray-100 min-w-[100px] text-center tracking-wide text-sm shadow-sm">Tiebreaker Score</th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white">
                                        {picks.map((player, rowIndex) => (
                                            <tr key={rowIndex} className="group hover:bg-blue-50 transition-colors border-b border-gray-100 last:border-0">
                                                <td className="sticky left-0 sticky-left p-2 text-left font-bold text-gray-900 border-r-2 border-gray-100 sticky-col-shadow bg-white">{player.Name}</td>
                                                {schedule.map((game, colIndex) => (<td key={colIndex} className="p-2 text-center border-r border-gray-100 last:border-0"><StatusPill pick={player[game.Bowl]} winner={game.Winner} /></td>))}
                                                <td className="p-2 text-center text-gray-700 font-medium text-[14px] border-l border-gray-100">{player["Tiebreaker Score"]}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 3. RACE PAGE
        const RacePage = () => {
            const [loading, setLoading] = useState(true);
            const [chartData, setChartData] = useState({ series: [], maxWins: 0, gameCount: 0 });
            const [hoveredPlayer, setHoveredPlayer] = useState(null);
            const [selectedPlayer, setSelectedPlayer] = useState(null);
            const [tableData, setTableData] = useState([]);

            // Define a vibrant color palette
            const COLORS = [
                "#ef4444", // Red-500
                "#f97316", // Orange-500
                "#f59e0b", // Amber-500
                "#84cc16", // Lime-500
                "#10b981", // Emerald-500
                "#06b6d4", // Cyan-500
                "#3b82f6", // Blue-500
                "#6366f1", // Indigo-500
                "#8b5cf6", // Violet-500
                "#d946ef", // Fuchsia-500
                "#f43f5e", // Rose-500
                "#64748b", // Slate-500
            ];

            const getColor = (idx) => COLORS[idx % COLORS.length];

            useEffect(() => {
                const init = async () => {
                    try {
                        const [scheduleRes, picksRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL)
                        ]);
                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();
                        const schedule = csvToJson(scheduleText);
                        const picks = csvToJson(picksText).filter(p => p.Name);

                        // Process Schedule - Get completed games strictly ordered by time
                        const sortedSchedule = schedule
                            .filter(g => g.Date && g.Time && g.Winner)
                            .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                        const players = picks.map(p => p.Name);
                        // Initialize history with 0 wins at start (game 0)
                        const history = {};
                        players.forEach(p => history[p] = [0]);

                        sortedSchedule.forEach(game => {
                            players.forEach(playerObj => {
                                const playerPicks = picks.find(p => p.Name === playerObj);
                                const pick = playerPicks[game.Bowl];
                                const currentWins = history[playerObj][history[playerObj].length - 1];
                                // If pick matches winner, increment, else keep same
                                const isWin = pick && pick.toLowerCase() === game.Winner.toLowerCase();
                                history[playerObj].push(currentWins + (isWin ? 1 : 0));
                            });
                        });

                        const series = players.map((p, idx) => ({
                            name: p,
                            data: history[p],
                            color: getColor(idx)
                        }));

                        const gameCount = sortedSchedule.length;
                        const maxWins = Math.max(...series.map(s => s.data[s.data.length - 1]));

                        // Table data (current standing)
                        const tData = players.map((p, idx) => {
                            const wins = history[p][history[p].length - 1];
                            return { name: p, wins, color: getColor(idx) };
                        }).sort((a, b) => b.wins - a.wins);

                        setChartData({ series, maxWins, gameCount });
                        setTableData(tData);
                        setLoading(false);
                    } catch (e) {
                        console.error(e);
                        setLoading(false);
                    }
                };
                init();
            }, []);

            const activePlayer = selectedPlayer || hoveredPlayer;

            const getLineStyle = (player) => {
                if (activePlayer === player.name) {
                    return { stroke: player.color, strokeWidth: 4, opacity: 1, zIndex: 50 };
                }
                if (activePlayer) {
                    // Dim others if one is active
                    return { stroke: '#cbd5e1', strokeWidth: 1.5, opacity: 0.3, zIndex: 1 };
                }
                // Default state
                return { stroke: player.color, strokeWidth: 2, opacity: 0.8, zIndex: 10 };
            };

            if (loading) return <LoadingSpinner text="Analyzing the race..." />;

            // Chart Dimensions
            const VIEWBOX_WIDTH = 1000;
            const VIEWBOX_HEIGHT = 400;
            const PADDING_TOP = 20;
            const PADDING_BOTTOM = 40;
            const PADDING_LEFT = 40;
            const PADDING_RIGHT = 30;

            // Avoid division by zero if no games played
            const xStep = chartData.gameCount > 0 ? (VIEWBOX_WIDTH - PADDING_LEFT - PADDING_RIGHT) / chartData.gameCount : 0;
            // Y scale based on maxWins + padding so line doesn't hit absolute top
            const yDomain = chartData.maxWins > 0 ? chartData.maxWins : 5;
            const yScale = (val) => (VIEWBOX_HEIGHT - PADDING_BOTTOM) - ((val / yDomain) * (VIEWBOX_HEIGHT - PADDING_TOP - PADDING_BOTTOM));

            // Create a safe sorted copy of series for rendering
            const sortedSeries = [...chartData.series].sort((a, b) => (a.name === activePlayer ? 1 : b.name === activePlayer ? -1 : 0));

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-8 px-4">
                        <div className="max-w-7xl mx-auto text-center">
                            <h2 className="text-3xl text-blue-900 font-bold mb-1">The Race</h2>
                            <p className="text-gray-600 text-sm">Track the rise (and fall) of every player.</p>
                        </div>
                    </div>

                    <div className="px-2 md:px-6 flex flex-col items-center gap-8">

                        {/* CHART CARD */}
                        <div className="w-full max-w-[98%] md:max-w-[90%] bg-white rounded-xl shadow-2xl border border-gray-100 overflow-hidden p-4 md:p-6">
                            {chartData.gameCount === 0 ? (
                                <div className="text-center text-gray-400 py-12 italic">No games completed yet. The race hasn't started!</div>
                            ) : (
                                <div className="w-full overflow-hidden">
                                    <svg viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`} className="w-full h-auto block select-none">

                                        {/* Wins Label */}
                                        <text
                                            x={PADDING_LEFT - 10}
                                            y={12}
                                            textAnchor="end"
                                            className="text-[10px] fill-gray-400 font-bold uppercase tracking-wider hidden md:block"
                                            style={{ fontSize: '10px' }}
                                        >
                                            WINS
                                        </text>

                                        {/* Y-Axis Grid & Labels */}
                                        {[...Array(yDomain + 1)].map((_, i) => (
                                            <g key={`y-grid-${i}`}>
                                                <line
                                                    x1={PADDING_LEFT}
                                                    y1={yScale(i)}
                                                    x2={VIEWBOX_WIDTH - PADDING_RIGHT}
                                                    y2={yScale(i)}
                                                    stroke="#f1f5f9"
                                                    strokeWidth="1"
                                                />
                                                <text
                                                    x={PADDING_LEFT - 10}
                                                    y={yScale(i) + 4}
                                                    textAnchor="end"
                                                    className="text-[12px] fill-gray-400 font-bold"
                                                    style={{ fontSize: '12px' }}
                                                >
                                                    {i}
                                                </text>
                                            </g>
                                        ))}

                                        {/* X-Axis Labels (Every 5 games if many, else every 1) */}
                                        {[...Array(chartData.gameCount + 1)].map((_, i) => {
                                            if (chartData.gameCount > 20 && i % 5 !== 0 && i !== chartData.gameCount) return null;
                                            return (
                                                <text
                                                    key={`x-label-${i}`}
                                                    x={PADDING_LEFT + i * xStep}
                                                    y={VIEWBOX_HEIGHT - 10}
                                                    textAnchor="middle"
                                                    className="text-[12px] fill-gray-400 font-bold"
                                                    style={{ fontSize: '12px' }}
                                                >
                                                    {i}
                                                </text>
                                            );
                                        })}

                                        {/* Lines & Dots */}
                                        {sortedSeries.map((player) => {
                                            const style = getLineStyle(player);
                                            const points = player.data.map((wins, gameIdx) =>
                                                `${PADDING_LEFT + gameIdx * xStep},${yScale(wins)}`
                                            ).join(' ');

                                            // Last point coordinates for dot
                                            const lastX = PADDING_LEFT + (player.data.length - 1) * xStep;
                                            const lastY = yScale(player.data[player.data.length - 1]);

                                            return (
                                                <g key={player.name}>
                                                    <polyline
                                                        points={points}
                                                        fill="none"
                                                        stroke={style.stroke}
                                                        strokeWidth={style.strokeWidth}
                                                        strokeLinecap="round"
                                                        strokeLinejoin="round"
                                                        opacity={style.opacity}
                                                        className="transition-all duration-300 ease-in-out"
                                                    />
                                                    <circle
                                                        cx={lastX}
                                                        cy={lastY}
                                                        r={activePlayer === player.name ? 6 : 3}
                                                        fill={style.stroke}
                                                        opacity={style.opacity}
                                                        className="transition-all duration-300 ease-in-out"
                                                    />
                                                </g>
                                            );
                                        })}
                                    </svg>
                                    <div className="hidden md:flex justify-end text-xs text-gray-400 mt-2 font-bold uppercase tracking-wider">
                                        <span>Games Played</span>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* PLAYERS GRID */}
                        <div className="w-full max-w-[98%] md:max-w-[90%] bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden flex flex-col">
                            <div className="px-4 py-3 border-b border-gray-100">
                                <h3 className="text-lg font-bold text-gray-900 font-serif">Win Count</h3>
                            </div>
                            <div
                                className="p-4"
                                onMouseLeave={() => setHoveredPlayer(null)}
                            >
                                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                    {tableData.map((player) => {
                                        const isSelected = selectedPlayer === player.name;
                                        const isHighlighted = activePlayer === player.name;

                                        // Dynamic styles for the card
                                        let cardStyle = "border-transparent hover:bg-gray-50 hover:border-gray-100";
                                        if (isSelected) {
                                            cardStyle = "bg-blue-50 border-blue-200 ring-1 ring-blue-300";
                                        } else if (isHighlighted) {
                                            cardStyle = "bg-gray-100 border-gray-200";
                                        }

                                        // Text styles
                                        const nameStyle = isSelected || isHighlighted ? 'text-gray-900 font-bold' : 'text-gray-700 font-medium';

                                        return (
                                            <div
                                                key={player.name}
                                                onMouseEnter={() => setHoveredPlayer(player.name)}
                                                onClick={() => setSelectedPlayer(selectedPlayer === player.name ? null : player.name)}
                                                className={`flex items-center justify-between p-3 rounded-lg cursor-pointer transition-all border ${cardStyle}`}
                                            >
                                                <div className="flex items-center gap-3">
                                                    <div className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: player.color }}></div>
                                                    <span className={`text-sm truncate ${nameStyle}`}>
                                                        {player.name}
                                                    </span>
                                                </div>
                                                <span className="font-bold text-lg text-gray-900">{player.wins}</span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        // 4. BADGES PAGE (New)
        const BadgeCard = ({ emoji, title, winners, description, colorTheme }) => {
            const [showList, setShowList] = useState(false);
            const isTie = winners.length > 1;

            const winnerText = isTie ? `${winners.length} Tied` : (winners.length > 0 ? winners[0] : "TBD");

            return (
                <div
                    className={`relative overflow-hidden rounded-2xl border p-6 shadow-md transition-all hover:scale-[1.02] hover:shadow-xl ${colorTheme.bg} ${colorTheme.text} ${colorTheme.border}`}
                >
                    <div className="flex items-start justify-between">
                        <div className="flex-1 mr-2 relative z-10">
                            <p className="text-xs font-bold uppercase tracking-widest opacity-70 mb-1">{title}</p>
                            <h3 className="text-xl font-black leading-tight text-gray-900 mb-2 truncate">{winnerText}</h3>

                            {isTie && (
                                <button
                                    onClick={() => setShowList(!showList)}
                                    className="text-xs font-bold hover:underline flex items-center gap-1 focus:outline-none opacity-80 hover:opacity-100 transition-opacity"
                                >
                                    {showList ? "Hide List" : "View List"}
                                    <span className="text-[10px] ml-1">{showList ? "‚ñ≤" : "‚ñº"}</span>
                                </button>
                            )}
                        </div>
                        <div className="flex h-12 w-12 items-center justify-center rounded-full bg-white/50 text-3xl shadow-sm backdrop-blur-sm flex-shrink-0">
                            {emoji}
                        </div>
                    </div>

                    {showList && isTie ? (
                        <div className="mt-4 bg-white/40 rounded-lg p-2 max-h-32 overflow-y-auto backdrop-blur-sm">
                            <ul className="text-sm font-medium">
                                {winners.map((w, idx) => (
                                    <li key={idx} className="border-b border-black/5 last:border-0 py-1 px-1">{w}</li>
                                ))}
                            </ul>
                        </div>
                    ) : (
                        <p className="mt-4 text-sm font-medium leading-relaxed opacity-90">
                            {description}
                        </p>
                    )}
                </div>
            );
        };

        const BadgesPage = () => {
            const [badges, setBadges] = useState([]);
            const [loading, setLoading] = useState(true);

            // Theme palette for random assignment
            const THEMES = useMemo(() => [
                { bg: "bg-indigo-100", text: "text-indigo-800", border: "border-indigo-300" },
                { bg: "bg-emerald-100", text: "text-emerald-800", border: "border-emerald-300" },
                { bg: "bg-amber-100", text: "text-amber-800", border: "border-amber-300" },
                { bg: "bg-rose-100", text: "text-rose-800", border: "border-rose-300" },
                { bg: "bg-cyan-100", text: "text-cyan-800", border: "border-cyan-300" },
                { bg: "bg-violet-100", text: "text-violet-800", border: "border-violet-300" },
            ], []);

            useEffect(() => {
                const init = async () => {
                    try {
                        const [scheduleRes, picksRes, historyRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL),
                            fetch(HISTORY_URL)
                        ]);
                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();
                        const historyText = await historyRes.text();

                        const schedule = csvToJson(scheduleText);
                        const picks = csvToJson(picksText).filter(p => p.Name);
                        const history = csvToJson(historyText);

                        // Mocks
                        const MOCK_BADGES = [];

                        const calculatedBadges = [];

                        // ----------------------------------------------------
                        // BADGE 1: NIGHT OWL
                        // Most wins in games starting 7 PM or later
                        // ----------------------------------------------------
                        try {
                            const nightGames = schedule.filter(g => {
                                if (!g.Winner || !g.Time) return false;
                                const timeStr = g.Time.trim().toUpperCase();
                                let [timePart, modifier] = timeStr.split(' ');
                                if (!modifier) {
                                    if (timeStr.includes('PM')) { modifier = 'PM'; timePart = timeStr.replace('PM',''); }
                                    else if (timeStr.includes('AM')) { modifier = 'AM'; timePart = timeStr.replace('AM',''); }
                                }
                                let [hours, minutes] = timePart.split(':').map(Number);
                                if (modifier === 'PM' && hours !== 12) hours += 12;
                                if (modifier === 'AM' && hours === 12) hours = 0;
                                return hours >= 19;
                            });

                            if (nightGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);
                                nightGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) playerWins[p.Name]++;
                                    });
                                });
                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });
                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];
                                calculatedBadges.push({
                                    emoji: "ü¶â",
                                    title: "Night Owl",
                                    winners: winners,
                                    description: `Thrives in the dark. Most wins (${maxWins}) in games starting 7 PM or later.`,
                                    colorTheme: { bg: "bg-indigo-100", text: "text-indigo-800", border: "border-indigo-300" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "ü¶â",
                                    title: "Night Owl",
                                    winners: [],
                                    description: "Thrives in the dark. Most wins in games starting 7 PM or later.",
                                    colorTheme: { bg: "bg-indigo-100", text: "text-indigo-800", border: "border-indigo-300" }
                                });
                            }
                        } catch (e) { console.error("Night Owl Error", e); }

                        // ----------------------------------------------------
                        // BADGE 2: EARLY RISER
                        // Most wins in games starting 2 PM (14:00) or earlier
                        // ----------------------------------------------------
                        try {
                            const earlyGames = schedule.filter(g => {
                                if (!g.Winner || !g.Time) return false;
                                const timeStr = g.Time.trim().toUpperCase();
                                let [timePart, modifier] = timeStr.split(' ');
                                if (!modifier) {
                                    if (timeStr.includes('PM')) { modifier = 'PM'; timePart = timeStr.replace('PM',''); }
                                    else if (timeStr.includes('AM')) { modifier = 'AM'; timePart = timeStr.replace('AM',''); }
                                }
                                let [hours, minutes] = timePart.split(':').map(Number);
                                if (modifier === 'PM' && hours !== 12) hours += 12;
                                if (modifier === 'AM' && hours === 12) hours = 0;

                                // 14:00 is 2 PM
                                return (hours < 14) || (hours === 14 && minutes === 0);
                            });

                            if (earlyGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);
                                earlyGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) playerWins[p.Name]++;
                                    });
                                });
                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });
                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];
                                calculatedBadges.push({
                                    emoji: "üåÖ",
                                    title: "Early Riser",
                                    winners: winners,
                                    description: `Catches the worm. Most wins (${maxWins}) in games starting 2 PM or earlier.`,
                                    colorTheme: { bg: "bg-orange-100", text: "text-orange-900", border: "border-orange-300" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üåÖ",
                                    title: "Early Riser",
                                    winners: [],
                                    description: "Catches the worm. Most wins in games starting 2 PM or earlier.",
                                    colorTheme: { bg: "bg-orange-100", text: "text-orange-900", border: "border-orange-300" }
                                });
                            }
                        } catch (e) { console.error("Early Riser Error", e); }

                        // ----------------------------------------------------
                        // BADGE 3: THE TWINS
                        // Longest streak of identical picks between 2 players
                        // ----------------------------------------------------
                        try {
                            // 1. Sort Schedule Chronologically
                            const chronoSchedule = schedule
                                .filter(g => g.Date && g.Time)
                                .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                            let maxTwinStreak = 0;
                            let twinWinners = []; // Array of strings like "Alice & Bob"
                            const playerNames = picks.map(p => p.Name);

                            // 2. Iterate all unique pairs
                            for (let i = 0; i < playerNames.length; i++) {
                                for (let j = i + 1; j < playerNames.length; j++) {
                                    const p1 = playerNames[i];
                                    const p2 = playerNames[j];
                                    const p1Picks = picks.find(p => p.Name === p1);
                                    const p2Picks = picks.find(p => p.Name === p2);

                                    let currentStreak = 0;
                                    let pairMax = 0;

                                    chronoSchedule.forEach(game => {
                                        const pick1 = p1Picks[game.Bowl];
                                        const pick2 = p2Picks[game.Bowl];

                                        // Check if both made a pick and they are identical (case-insensitive)
                                        if (pick1 && pick2 && pick1.trim().toLowerCase() === pick2.trim().toLowerCase()) {
                                            currentStreak++;
                                        } else {
                                            if (currentStreak > pairMax) pairMax = currentStreak;
                                            currentStreak = 0;
                                        }
                                    });
                                    // Final check
                                    if (currentStreak > pairMax) pairMax = currentStreak;

                                    // Update global stats
                                    if (pairMax > maxTwinStreak) {
                                        maxTwinStreak = pairMax;
                                        twinWinners = [`${p1} & ${p2}`];
                                    } else if (pairMax === maxTwinStreak && pairMax > 0) {
                                        twinWinners.push(`${p1} & ${p2}`);
                                    }
                                }
                            }

                            calculatedBadges.push({
                                emoji: "üëØ",
                                title: "The Twins",
                                winners: twinWinners.length > 0 ? twinWinners : [],
                                description: `In sync. Longest streak of identical picks (${maxTwinStreak > 0 ? maxTwinStreak : 0} games).`,
                                colorTheme: { bg: "bg-purple-100", text: "text-purple-800", border: "border-purple-300" }
                            });

                        } catch (e) {
                            console.error("The Twins Error", e);
                            calculatedBadges.push({
                                emoji: "üëØ",
                                title: "The Twins",
                                winners: [],
                                description: "In sync. Longest streak of identical picks.",
                                colorTheme: { bg: "bg-purple-100", text: "text-purple-800", border: "border-purple-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 4: THE JINX
                        // Most shared losses on identical picks between 2 players
                        // ----------------------------------------------------
                        try {
                             let maxSharedLosses = 0;
                             let jinxWinners = [];
                             const playerNames = picks.map(p => p.Name);

                             // Iterate all unique pairs
                             for (let i = 0; i < playerNames.length; i++) {
                                 for (let j = i + 1; j < playerNames.length; j++) {
                                     const p1 = playerNames[i];
                                     const p2 = playerNames[j];
                                     const p1Picks = picks.find(p => p.Name === p1);
                                     const p2Picks = picks.find(p => p.Name === p2);

                                     let currentSharedLosses = 0;

                                     schedule.forEach(game => {
                                         // Only count if game is finished
                                         if (!game.Winner) return;

                                         const pick1 = p1Picks[game.Bowl];
                                         const pick2 = p2Picks[game.Bowl];
                                         const winner = game.Winner;

                                         // Check if identical picks and both lost
                                         if (pick1 && pick2 &&
                                             pick1.trim().toLowerCase() === pick2.trim().toLowerCase() &&
                                             pick1.trim().toLowerCase() !== winner.trim().toLowerCase()) {
                                             currentSharedLosses++;
                                         }
                                     });

                                     if (currentSharedLosses > maxSharedLosses) {
                                         maxSharedLosses = currentSharedLosses;
                                         jinxWinners = [`${p1} & ${p2}`];
                                     } else if (currentSharedLosses === maxSharedLosses && maxSharedLosses > 0) {
                                         jinxWinners.push(`${p1} & ${p2}`);
                                     }
                                 }
                             }

                             calculatedBadges.push({
                                 emoji: "üêà‚Äç‚¨õ",
                                 title: "The Jinx",
                                 winners: jinxWinners.length > 0 ? jinxWinners : [],
                                 description: `Misery loves company. Most shared losses on identical picks (${maxSharedLosses} games).`,
                                 colorTheme: { bg: "bg-slate-200", text: "text-slate-800", border: "border-slate-400" }
                             });

                        } catch (e) {
                            console.error("The Jinx Error", e);
                            calculatedBadges.push({
                                 emoji: "üêà‚Äç‚¨õ",
                                 title: "The Jinx",
                                 winners: [],
                                 description: "Misery loves company. Most shared losses on identical picks.",
                                 colorTheme: { bg: "bg-slate-200", text: "text-slate-800", border: "border-slate-400" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 5: THE HEATER
                        // Longest winning streak of the season
                        // ----------------------------------------------------
                        try {
                            // Get strictly chronological completed games
                            const completedSchedule = schedule
                                .filter(g => g.Date && g.Time && g.Winner)
                                .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                            let globalMaxStreak = 0;
                            const playerMaxStreaks = {}; // name -> maxStreak

                            picks.forEach(player => {
                                let currentStreak = 0;
                                let maxStreak = 0;

                                completedSchedule.forEach(game => {
                                    const pick = player[game.Bowl];
                                    const winner = game.Winner;

                                    if (pick && pick.toLowerCase() === winner.toLowerCase()) {
                                        currentStreak++;
                                    } else {
                                        // Streak broken
                                        if (currentStreak > maxStreak) maxStreak = currentStreak;
                                        currentStreak = 0;
                                    }
                                });
                                // Check if streak was active at the end
                                if (currentStreak > maxStreak) maxStreak = currentStreak;

                                playerMaxStreaks[player.Name] = maxStreak;
                                if (maxStreak > globalMaxStreak) globalMaxStreak = maxStreak;
                            });

                            const winners = Object.keys(playerMaxStreaks).filter(name => playerMaxStreaks[name] === globalMaxStreak && globalMaxStreak > 0);

                            calculatedBadges.push({
                                emoji: "üî•",
                                title: "The Heater",
                                winners: winners.length > 0 ? winners : [],
                                description: `Can't miss. Longest winning streak of the season (${globalMaxStreak} games).`,
                                colorTheme: { bg: "bg-orange-100", text: "text-orange-800", border: "border-orange-300" }
                            });

                        } catch (e) {
                            console.error("The Heater Error", e);
                            calculatedBadges.push({
                                emoji: "üî•",
                                title: "The Heater",
                                winners: [],
                                description: "Can't miss. Longest winning streak of the season.",
                                colorTheme: { bg: "bg-orange-100", text: "text-orange-800", border: "border-orange-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 6: B1G WINNER
                        // Most wins in B1G designated games
                        // ----------------------------------------------------
                        try {
                            const bigTenGames = schedule.filter(g => g.Winner && g['B1G']);

                            if (bigTenGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);

                                bigTenGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            playerWins[p.Name]++;
                                        }
                                    });
                                });

                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });

                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];

                                calculatedBadges.push({
                                    emoji: "üå∞",
                                    title: "B1G Winner",
                                    winners: winners,
                                    description: `Dominating the conference. Most wins (${maxWins}) in Big Ten matchups.`,
                                    colorTheme: { bg: "bg-[#ba0c2f]/10", text: "text-[#ba0c2f]", border: "border-[#ba0c2f]/30" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üå∞",
                                    title: "B1G Winner",
                                    winners: [],
                                    description: "Dominating the conference. Most wins in Big Ten matchups.",
                                    colorTheme: { bg: "bg-[#ba0c2f]/10", text: "text-[#ba0c2f]", border: "border-[#ba0c2f]/30" }
                                });
                            }
                        } catch (e) {
                            console.error("B1G Winner Error", e);
                            calculatedBadges.push({
                                emoji: "üå∞",
                                title: "B1G Winner",
                                winners: [],
                                description: "Dominating the conference. Most wins in Big Ten matchups.",
                                colorTheme: { bg: "bg-[#ba0c2f]/10", text: "text-[#ba0c2f]", border: "border-[#ba0c2f]/30" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 7: IT JUST MEANS MORE (SEC)
                        // Most wins in SEC designated games
                        // ----------------------------------------------------
                        try {
                            const secGames = schedule.filter(g => g.Winner && g['SEC']);

                            if (secGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);

                                secGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            playerWins[p.Name]++;
                                        }
                                    });
                                });

                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });

                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];

                                calculatedBadges.push({
                                    emoji: "üê∂",
                                    title: "It Just Means More",
                                    winners: winners,
                                    description: `SEC supremacy. Most wins (${maxWins}) in SEC matchups.`,
                                    colorTheme: { bg: "bg-blue-100", text: "text-blue-900", border: "border-blue-300" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üê∂",
                                    title: "It Just Means More",
                                    winners: [],
                                    description: "SEC supremacy. Most wins in SEC matchups.",
                                    colorTheme: { bg: "bg-blue-100", text: "text-blue-900", border: "border-blue-300" }
                                });
                            }
                        } catch (e) {
                            console.error("SEC Winner Error", e);
                            calculatedBadges.push({
                                emoji: "üê∂",
                                title: "It Just Means More",
                                winners: [],
                                description: "SEC supremacy. Most wins in SEC matchups.",
                                colorTheme: { bg: "bg-blue-100", text: "text-blue-900", border: "border-blue-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 8: THE SHEEP
                        // Player that most often follows the herd
                        // ----------------------------------------------------
                        try {
                            const sheepScores = {};
                            picks.forEach(p => sheepScores[p.Name] = 0);

                            schedule.forEach(game => {
                                // 1. Tally picks for this game
                                const counts = {};
                                picks.forEach(p => {
                                    const pick = p[game.Bowl];
                                    if (pick) {
                                        const normPick = pick.trim();
                                        counts[normPick] = (counts[normPick] || 0) + 1;
                                    }
                                });

                                // 2. Find Majority
                                let maxCount = 0;
                                let majorityPick = null;
                                let isTie = false;

                                Object.entries(counts).forEach(([pick, count]) => {
                                    if (count > maxCount) {
                                        maxCount = count;
                                        majorityPick = pick;
                                        isTie = false;
                                    } else if (count === maxCount) {
                                        isTie = true;
                                    }
                                });

                                // 3. Award points if player picked majority
                                if (majorityPick && !isTie) {
                                    picks.forEach(p => {
                                        const pick = p[game.Bowl];
                                        if (pick && pick.trim() === majorityPick) {
                                            sheepScores[p.Name]++;
                                        }
                                    });
                                }
                            });

                            let maxSheepScore = -1;
                            Object.values(sheepScores).forEach(s => { if (s > maxSheepScore) maxSheepScore = s; });

                            let winners = maxSheepScore > 0 ? Object.keys(sheepScores).filter(n => sheepScores[n] === maxSheepScore) : [];

                            calculatedBadges.push({
                                emoji: "üêë",
                                title: "The Sheep",
                                winners: winners,
                                description: `Baaaaa. Followed the group majority in ${maxSheepScore} games.`,
                                colorTheme: { bg: "bg-gray-50", text: "text-gray-600", border: "border-gray-200" }
                            });

                        } catch (e) {
                            console.error("The Sheep Error", e);
                            calculatedBadges.push({
                                emoji: "üêë",
                                title: "The Sheep",
                                winners: [],
                                description: "Baaaaa. Follows the group majority most often.",
                                colorTheme: { bg: "bg-gray-50", text: "text-gray-600", border: "border-gray-200" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 9: SUB-ZERO
                        // Longest losing streak of the season
                        // ----------------------------------------------------
                        try {
                            // Reuse completedSchedule from "The Heater" logic if scope allows, otherwise redefine
                            const completedSchedule = schedule
                                .filter(g => g.Date && g.Time && g.Winner)
                                .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                            let globalMaxLosingStreak = 0;
                            const playerMaxLossStreaks = {};

                            picks.forEach(player => {
                                let currentStreak = 0;
                                let maxStreak = 0;

                                completedSchedule.forEach(game => {
                                    const pick = player[game.Bowl];
                                    const winner = game.Winner;

                                    // If pick exists and matches winner -> WIN. Anything else (wrong pick or no pick) -> LOSS
                                    if (pick && pick.toLowerCase() === winner.toLowerCase()) {
                                        // Win breaks the losing streak
                                        if (currentStreak > maxStreak) maxStreak = currentStreak;
                                        currentStreak = 0;
                                    } else {
                                        // Loss increments the losing streak
                                        currentStreak++;
                                    }
                                });
                                // Check active streak at end
                                if (currentStreak > maxStreak) maxStreak = currentStreak;

                                playerMaxLossStreaks[player.Name] = maxStreak;
                                if (maxStreak > globalMaxLosingStreak) globalMaxLosingStreak = maxStreak;
                            });

                            const winners = Object.keys(playerMaxLossStreaks).filter(name => playerMaxLossStreaks[name] === globalMaxLosingStreak && globalMaxLosingStreak > 0);

                            calculatedBadges.push({
                                emoji: "ü•∂",
                                title: "Sub-Zero",
                                winners: winners.length > 0 ? winners : [],
                                description: `Ice cold. Longest losing streak of the season (${globalMaxLosingStreak} games).`,
                                colorTheme: { bg: "bg-cyan-50", text: "text-cyan-900", border: "border-cyan-200" }
                            });

                        } catch (e) {
                            console.error("Sub-Zero Error", e);
                            calculatedBadges.push({
                                emoji: "ü•∂",
                                title: "Sub-Zero",
                                winners: [],
                                description: "Ice cold. Longest losing streak of the season.",
                                colorTheme: { bg: "bg-cyan-50", text: "text-cyan-900", border: "border-cyan-200" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 11: THE SNIPER
                        // Player(s) who correctly picked a game that the smallest amount of the total group picked correctly
                        // ----------------------------------------------------
                        try {
                            // 1. Calculate correct pick counts for every completed game
                            let minCorrectCount = Infinity;
                            let hardestGames = []; // Stores { bowlName: string, winningTeam: string, winners: string[] }

                            schedule.forEach(game => {
                                if (!game.Winner) return;

                                const correctPickers = [];
                                picks.forEach(p => {
                                    const pick = p[game.Bowl];
                                    if (pick && pick.toLowerCase() === game.Winner.toLowerCase()) {
                                        correctPickers.push(p.Name);
                                    }
                                });

                                const count = correctPickers.length;

                                // We are looking for the lowest non-zero count (if count is 0, nobody sniped it)
                                if (count > 0) {
                                    if (count < minCorrectCount) {
                                        minCorrectCount = count;
                                        hardestGames = [{ bowl: game.Bowl, winningTeam: game.Winner, winners: correctPickers }];
                                    } else if (count === minCorrectCount) {
                                        hardestGames.push({ bowl: game.Bowl, winningTeam: game.Winner, winners: correctPickers });
                                    }
                                }
                            });

                            // Flatten winners list (handle duplicates if a player sniped multiple hard games)
                            const allSnipers = [...new Set(hardestGames.flatMap(g => g.winners))];

                            // Construct description
                            let descText = "Precision picking.";
                            if (hardestGames.length === 1) {
                                descText = `Lone wolf. Correctly picked ${hardestGames[0].winningTeam} when only ${minCorrectCount} person${minCorrectCount > 1 ? 's' : ''} got it right.`;
                            } else if (hardestGames.length > 1) {
                                descText = `Eagle eye. Correctly picked the hardest games of the season (only ${minCorrectCount} correct picks).`;
                            } else {
                                descText = "Precision picking. Correctly picked the game that fooled everyone else.";
                            }

                            calculatedBadges.push({
                                emoji: "üéØ",
                                title: "The Sniper",
                                winners: allSnipers.length > 0 ? allSnipers : [],
                                description: descText,
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });

                        } catch (e) {
                            console.error("The Sniper Error", e);
                            calculatedBadges.push({
                                emoji: "üéØ",
                                title: "The Sniper",
                                winners: [],
                                description: "Precision picking. Correctly picked the game that fooled everyone else.",
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 12: MIND MELD
                        // Highest agreement rate between two players
                        // ----------------------------------------------------
                        try {
                            let maxAgreementRate = -1;
                            let mindMeldWinners = [];
                            let bestPercentageStr = "0%";

                            const playerNames = picks.map(p => p.Name);

                            // Iterate unique pairs
                            for (let i = 0; i < playerNames.length; i++) {
                                for (let j = i + 1; j < playerNames.length; j++) {
                                    const p1 = playerNames[i];
                                    const p2 = playerNames[j];
                                    const p1Picks = picks.find(p => p.Name === p1);
                                    const p2Picks = picks.find(p => p.Name === p2);

                                    let agreements = 0;
                                    let commonGames = 0;

                                    schedule.forEach(game => {
                                        const pick1 = p1Picks[game.Bowl];
                                        const pick2 = p2Picks[game.Bowl];

                                        // Only count if both made a pick
                                        if (pick1 && pick2) {
                                            commonGames++;
                                            if (pick1.trim().toLowerCase() === pick2.trim().toLowerCase()) {
                                                agreements++;
                                            }
                                        }
                                    });

                                    if (commonGames > 0) {
                                        const rate = agreements / commonGames;

                                        if (rate > maxAgreementRate) {
                                            maxAgreementRate = rate;
                                            mindMeldWinners = [`${p1} & ${p2}`];
                                            bestPercentageStr = (rate * 100).toFixed(1) + "%";
                                        } else if (Math.abs(rate - maxAgreementRate) < 0.0001) { // Handle floating point equality
                                            mindMeldWinners.push(`${p1} & ${p2}`);
                                        }
                                    }
                                }
                            }

                            calculatedBadges.push({
                                emoji: "‚ô•Ô∏è",
                                title: "Mind Meld",
                                winners: mindMeldWinners.length > 0 ? mindMeldWinners : [],
                                description: `Great minds think alike. Highest agreement rate on picks (${bestPercentageStr}).`,
                                colorTheme: { bg: "bg-rose-100", text: "text-rose-900", border: "border-rose-300" }
                            });

                        } catch (e) {
                            console.error("Mind Meld Error", e);
                            calculatedBadges.push({
                                emoji: "‚ô•Ô∏è",
                                title: "Mind Meld",
                                winners: [],
                                description: "Great minds think alike. Highest agreement rate between two players.",
                                colorTheme: { bg: "bg-rose-100", text: "text-rose-900", border: "border-rose-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 13: MORTAL ENEMIES
                        // Lowest agreement rate between two players
                        // ----------------------------------------------------
                        try {
                            let minAgreementRate = 2; // Start higher than 100%
                            let mortalEnemiesWinners = [];
                            let worstPercentageStr = "100%";

                            const playerNames = picks.map(p => p.Name);

                            // Iterate unique pairs
                            for (let i = 0; i < playerNames.length; i++) {
                                for (let j = i + 1; j < playerNames.length; j++) {
                                    const p1 = playerNames[i];
                                    const p2 = playerNames[j];
                                    const p1Picks = picks.find(p => p.Name === p1);
                                    const p2Picks = picks.find(p => p.Name === p2);

                                    let agreements = 0;
                                    let commonGames = 0;

                                    schedule.forEach(game => {
                                        const pick1 = p1Picks[game.Bowl];
                                        const pick2 = p2Picks[game.Bowl];

                                        // Only count if both made a pick
                                        if (pick1 && pick2) {
                                            commonGames++;
                                            if (pick1.trim().toLowerCase() === pick2.trim().toLowerCase()) {
                                                agreements++;
                                            }
                                        }
                                    });

                                    if (commonGames > 0) {
                                        const rate = agreements / commonGames;

                                        if (rate < minAgreementRate) {
                                            minAgreementRate = rate;
                                            mortalEnemiesWinners = [`${p1} & ${p2}`];
                                            worstPercentageStr = (rate * 100).toFixed(1) + "%";
                                        } else if (Math.abs(rate - minAgreementRate) < 0.0001) {
                                            mortalEnemiesWinners.push(`${p1} & ${p2}`);
                                        }
                                    }
                                }
                            }

                            calculatedBadges.push({
                                emoji: "‚öîÔ∏è",
                                title: "Mortal Enemies",
                                winners: mortalEnemiesWinners.length > 0 ? mortalEnemiesWinners : [],
                                description: `Total opposites. Lowest agreement rate on picks (${worstPercentageStr}).`,
                                colorTheme: { bg: "bg-gray-300", text: "text-gray-900", border: "border-gray-400" }
                            });

                        } catch (e) {
                            console.error("Mortal Enemies Error", e);
                            calculatedBadges.push({
                                emoji: "‚öîÔ∏è",
                                title: "Mortal Enemies",
                                winners: [],
                                description: "Total opposites. Lowest agreement rate between two players.",
                                colorTheme: { bg: "bg-gray-300", text: "text-gray-900", border: "border-gray-400" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 14: KING SLAYER
                        // Most wins in games where the current leader(s) lost
                        // ----------------------------------------------------
                        try {
                            // 1. Determine Current Leader(s)
                            const currentWins = {};
                            picks.forEach(p => currentWins[p.Name] = 0);

                            schedule.forEach(game => {
                                if (!game.Winner) return;
                                picks.forEach(p => {
                                    const pick = p[game.Bowl];
                                    if (pick && pick.toLowerCase() === game.Winner.toLowerCase()) {
                                        currentWins[p.Name]++;
                                    }
                                });
                            });

                            let maxTotalWins = -1;
                            Object.values(currentWins).forEach(w => { if (w > maxTotalWins) maxTotalWins = w; });
                            const leaders = Object.keys(currentWins).filter(n => currentWins[n] === maxTotalWins);

                            // 2. Identify games where ALL leaders lost
                            const vulnerableGames = schedule.filter(game => {
                                if (!game.Winner) return false;
                                // Check if every leader picked incorrectly (or didn't pick)
                                return leaders.every(leaderName => {
                                    const p = picks.find(i => i.Name === leaderName);
                                    const pick = p[game.Bowl];
                                    return !pick || pick.toLowerCase() !== game.Winner.toLowerCase();
                                });
                            });

                            // 3. Count wins in those specific games
                            if (vulnerableGames.length > 0) {
                                const slayerScores = {};
                                picks.forEach(p => slayerScores[p.Name] = 0);

                                vulnerableGames.forEach(game => {
                                    picks.forEach(p => {
                                        const pick = p[game.Bowl];
                                        if (pick && pick.toLowerCase() === game.Winner.toLowerCase()) {
                                            slayerScores[p.Name]++;
                                        }
                                    });
                                });

                                let maxSlayerScore = -1;
                                Object.values(slayerScores).forEach(s => { if (s > maxSlayerScore) maxSlayerScore = s; });

                                let winners = maxSlayerScore > 0 ? Object.keys(slayerScores).filter(n => slayerScores[n] === maxSlayerScore) : [];

                                calculatedBadges.push({
                                    emoji: "üëë",
                                    title: "King Slayer",
                                    winners: winners,
                                    description: `Takes down the giants. Won ${maxSlayerScore} games where the leader(s) stumbled.`,
                                    colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                                });
                            } else {
                                // Leaders haven't lost a game collectively yet
                                calculatedBadges.push({
                                    emoji: "üëë",
                                    title: "King Slayer",
                                    winners: [],
                                    description: "Takes down the giants. Most wins in games where the leader(s) lost.",
                                    colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                                });
                            }

                        } catch (e) {
                            console.error("King Slayer Error", e);
                            calculatedBadges.push({
                                emoji: "üëë",
                                title: "King Slayer",
                                winners: [],
                                description: "Takes down the giants. Most wins in games where the leader(s) lost.",
                                colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 15: THE AVENGERS
                        // Most shared wins together between two players
                        // ----------------------------------------------------
                        try {
                            let maxSharedWins = 0;
                            let wonderTwinsWinners = [];
                            const playerNames = picks.map(p => p.Name);

                            // Iterate all unique pairs
                            for (let i = 0; i < playerNames.length; i++) {
                                for (let j = i + 1; j < playerNames.length; j++) {
                                    const p1 = playerNames[i];
                                    const p2 = playerNames[j];
                                    const p1Picks = picks.find(p => p.Name === p1);
                                    const p2Picks = picks.find(p => p.Name === p2);

                                    let currentSharedWins = 0;

                                    schedule.forEach(game => {
                                        if (!game.Winner) return;

                                        const pick1 = p1Picks[game.Bowl];
                                        const pick2 = p2Picks[game.Bowl];
                                        const winner = game.Winner;

                                        // Both picked the winner
                                        if (pick1 && pick2 &&
                                            pick1.trim().toLowerCase() === winner.trim().toLowerCase() &&
                                            pick2.trim().toLowerCase() === winner.trim().toLowerCase()) {
                                            currentSharedWins++;
                                        }
                                    });

                                    if (currentSharedWins > maxSharedWins) {
                                        maxSharedWins = currentSharedWins;
                                        wonderTwinsWinners = [`${p1} & ${p2}`];
                                    } else if (currentSharedWins === maxSharedWins && maxSharedWins > 0) {
                                        wonderTwinsWinners.push(`${p1} & ${p2}`);
                                    }
                                }
                            }

                            calculatedBadges.push({
                                emoji: "üëä",
                                title: "The Avengers",
                                winners: wonderTwinsWinners.length > 0 ? wonderTwinsWinners : [],
                                description: `Dynamic duo. Most shared wins together (${maxSharedWins} games).`,
                                colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                            });

                        } catch (e) {
                            console.error("The Avengers Error", e);
                            calculatedBadges.push({
                                emoji: "üëä",
                                title: "The Avengers",
                                winners: [],
                                description: "Dynamic duo. Most shared wins together.",
                                colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 16: PLAYOFF PAYOFF
                        // Most wins in CFP designated games
                        // ----------------------------------------------------
                        try {
                            const cfpGames = schedule.filter(g => g.Winner && g['CFP']);

                            if (cfpGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);

                                cfpGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            playerWins[p.Name]++;
                                        }
                                    });
                                });

                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });

                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];

                                calculatedBadges.push({
                                    emoji: "üèÖ",
                                    title: "Playoff Payoff",
                                    winners: winners,
                                    description: `Big stage player. Most wins (${maxWins}) in College Football Playoff games.`,
                                    colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üèÖ",
                                    title: "Playoff Payoff",
                                    winners: [],
                                    description: "Big stage player. Most wins in College Football Playoff games.",
                                    colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                                });
                            }
                        } catch (e) {
                            console.error("Playoff Payoff Error", e);
                            calculatedBadges.push({
                                emoji: "üèÖ",
                                title: "Playoff Payoff",
                                winners: [],
                                description: "Big stage player. Most wins in College Football Playoff games.",
                                colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 17: CHAMPIONSHIP RIVALS
                        // Pair with highest agreement (>50%) but different Champs
                        // ----------------------------------------------------
                        try {
                            let maxRivalAgreement = 0;
                            let rivalWinners = [];
                            let agreementStr = "0%";
                            const playerNames = picks.map(p => p.Name);

                            for (let i = 0; i < playerNames.length; i++) {
                                for (let j = i + 1; j < playerNames.length; j++) {
                                    const p1Name = playerNames[i];
                                    const p2Name = playerNames[j];
                                    const p1 = picks.find(p => p.Name === p1Name);
                                    const p2 = picks.find(p => p.Name === p2Name);

                                    // Check Champs
                                    const c1 = p1["National Championship"];
                                    const c2 = p2["National Championship"];

                                    if (!c1 || !c2 || c1.trim().toLowerCase() === c2.trim().toLowerCase()) {
                                        continue;
                                    }

                                    // Calculate Agreement
                                    let agreements = 0;
                                    let common = 0;
                                    schedule.forEach(g => {
                                        const pick1 = p1[g.Bowl];
                                        const pick2 = p2[g.Bowl];
                                        if (pick1 && pick2) {
                                            common++;
                                            if (pick1.trim().toLowerCase() === pick2.trim().toLowerCase()) {
                                                agreements++;
                                            }
                                        }
                                    });

                                    if (common > 0) {
                                        const rate = agreements / common;
                                        if (rate > 0.50) {
                                            if (rate > maxRivalAgreement) {
                                                maxRivalAgreement = rate;
                                                rivalWinners = [`${p1Name} & ${p2Name}`];
                                                agreementStr = (rate * 100).toFixed(1) + "%";
                                            } else if (Math.abs(rate - maxRivalAgreement) < 0.0001) {
                                                rivalWinners.push(`${p1Name} & ${p2Name}`);
                                            }
                                        }
                                    }
                                }
                            }

                            calculatedBadges.push({
                                emoji: "ü•ä",
                                title: "Championship Rivals",
                                winners: rivalWinners.length > 0 ? rivalWinners : [],
                                description: `Friends until the end. ${agreementStr} agreement, but split on the title game.`,
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });

                        } catch (e) {
                            console.error("Championship Rivals Error", e);
                             calculatedBadges.push({
                                emoji: "ü•ä",
                                title: "Championship Rivals",
                                winners: [],
                                description: "Friends until the end. High agreement, but split on the title game.",
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 18: SATURDAY NIGHT FEVER
                        // Most wins in games on Saturday nights 7 PM or later
                        // ----------------------------------------------------
                        try {
                            // Filter for Saturday games >= 7:00 PM
                            const satNightGames = schedule.filter(g => {
                                if (!g.Winner || !g.Time || !g.Date) return false;

                                // Check Day of Week (Saturday is 6)
                                // Note: Assuming Date format allows JS to parse correctly (e.g. "Dec 28")
                                // Adding a year might be safer in production, but relying on browser heuristic for now
                                const d = new Date(`${g.Date} ${g.Time}`);
                                if (d.getDay() !== 6) return false; // 0=Sun, 1=Mon... 6=Sat

                                // Check Time >= 7 PM
                                const timeStr = g.Time.trim().toUpperCase();
                                let [timePart, modifier] = timeStr.split(' ');
                                if (!modifier) {
                                    if (timeStr.includes('PM')) { modifier = 'PM'; timePart = timeStr.replace('PM',''); }
                                    else if (timeStr.includes('AM')) { modifier = 'AM'; timePart = timeStr.replace('AM',''); }
                                }
                                let [hours, minutes] = timePart.split(':').map(Number);
                                if (modifier === 'PM' && hours !== 12) hours += 12;
                                if (modifier === 'AM' && hours === 12) hours = 0;

                                return hours >= 19;
                            });

                            if (satNightGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);

                                satNightGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            playerWins[p.Name]++;
                                        }
                                    });
                                });

                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });
                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];

                                calculatedBadges.push({
                                    emoji: "üï∫",
                                    title: "Saturday Night Fever",
                                    winners: winners,
                                    description: `Owns the prime time. Most wins (${maxWins}) in Saturday night games.`,
                                    colorTheme: { bg: "bg-[#701a75]/10", text: "text-[#701a75]", border: "border-[#701a75]/30" } // Velvet
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üï∫",
                                    title: "Saturday Night Fever",
                                    winners: [],
                                    description: "Owns the prime time. Most wins in Saturday night games.",
                                    colorTheme: { bg: "bg-[#701a75]/10", text: "text-[#701a75]", border: "border-[#701a75]/30" }
                                });
                            }

                        } catch (e) {
                            console.error("Saturday Night Fever Error", e);
                            calculatedBadges.push({
                                emoji: "üï∫",
                                title: "Saturday Night Fever",
                                winners: [],
                                description: "Owns the prime time. Most wins in Saturday night games.",
                                colorTheme: { bg: "bg-[#701a75]/10", text: "text-[#701a75]", border: "border-[#701a75]/30" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 19: THE TV GUIDE
                        // Most wins in games broadcast on ESPN
                        // ----------------------------------------------------
                        try {
                            const espnGames = schedule.filter(g => g.Winner && g.Network && g.Network.toUpperCase().includes('ESPN'));

                            if (espnGames.length > 0) {
                                const playerWins = {};
                                picks.forEach(p => playerWins[p.Name] = 0);

                                espnGames.forEach(g => {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            playerWins[p.Name]++;
                                        }
                                    });
                                });

                                let maxWins = -1;
                                Object.values(playerWins).forEach(w => { if(w > maxWins) maxWins = w; });

                                let winners = maxWins > 0 ? Object.keys(playerWins).filter(name => playerWins[name] === maxWins) : [];

                                calculatedBadges.push({
                                    emoji: "üì∫",
                                    title: "The TV Guide",
                                    winners: winners,
                                    description: `Glued to the screen. Most wins (${maxWins}) in games broadcast on ESPN networks.`,
                                    colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                                });
                            } else {
                                calculatedBadges.push({
                                    emoji: "üì∫",
                                    title: "The TV Guide",
                                    winners: [],
                                    description: "Glued to the screen. Most wins in games broadcast on ESPN networks.",
                                    colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                                });
                            }
                        } catch (e) {
                            console.error("TV Guide Error", e);
                            calculatedBadges.push({
                                emoji: "üì∫",
                                title: "The TV Guide",
                                winners: [],
                                description: "Glued to the screen. Most wins in games broadcast on ESPN networks.",
                                colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 20: CLEAN SHEET
                        // Most "perfect days" (100% wins on days with 3+ games)
                        // ----------------------------------------------------
                        try {
                            // 1. Group completed games by Date
                            const gamesByDate = {};
                            schedule.forEach(g => {
                                if (g.Winner && g.Date) {
                                    if (!gamesByDate[g.Date]) gamesByDate[g.Date] = [];
                                    gamesByDate[g.Date].push(g);
                                }
                            });

                            const perfectDayCounts = {};
                            picks.forEach(p => perfectDayCounts[p.Name] = 0);

                            // 2. Iterate dates with >= 3 games
                            Object.values(gamesByDate).forEach(dayGames => {
                                if (dayGames.length >= 3) {
                                    picks.forEach(p => {
                                        let allCorrect = true;
                                        for (const game of dayGames) {
                                            const pick = p[game.Bowl];
                                            if (!pick || pick.toLowerCase() !== game.Winner.toLowerCase()) {
                                                allCorrect = false;
                                                break;
                                            }
                                        }
                                        if (allCorrect) {
                                            perfectDayCounts[p.Name]++;
                                        }
                                    });
                                }
                            });

                            let maxPerfectDays = -1;
                            Object.values(perfectDayCounts).forEach(c => { if(c > maxPerfectDays) maxPerfectDays = c; });

                            let winners = maxPerfectDays > 0 ? Object.keys(perfectDayCounts).filter(n => perfectDayCounts[n] === maxPerfectDays) : [];

                            calculatedBadges.push({
                                emoji: "üßº",
                                title: "Clean Sheet",
                                winners: winners,
                                description: `Flawless victory. Achieved perfection on ${maxPerfectDays} day${maxPerfectDays !== 1 ? 's' : ''} (3+ games).`,
                                colorTheme: { bg: "bg-teal-100", text: "text-teal-800", border: "border-teal-300" }
                            });

                        } catch (e) {
                            console.error("Clean Sheet Error", e);
                            calculatedBadges.push({
                                emoji: "üßº",
                                title: "Clean Sheet",
                                winners: [],
                                description: "Flawless victory. Most perfect days with 100% accuracy.",
                                colorTheme: { bg: "bg-teal-100", text: "text-teal-800", border: "border-teal-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 21: ALPHABET SOUP
                        // Most wins picking the team that comes first alphabetically
                        // ----------------------------------------------------
                        try {
                            const alphaSoupScores = {};
                            picks.forEach(p => alphaSoupScores[p.Name] = 0);

                            schedule.forEach(game => {
                                if (!game.Winner || !game["Team 1"] || !game["Team 2"]) return;

                                const t1 = game["Team 1"].trim();
                                const t2 = game["Team 2"].trim();
                                // Determine which team is first alphabetically
                                const alphaTeam = t1.localeCompare(t2) < 0 ? t1 : t2;

                                // Only counts if the alphabetical team actually won
                                if (alphaTeam.toLowerCase() === game.Winner.toLowerCase()) {
                                    picks.forEach(p => {
                                        const pick = p[game.Bowl];
                                        if (pick && pick.toLowerCase() === alphaTeam.toLowerCase()) {
                                            alphaSoupScores[p.Name]++;
                                        }
                                    });
                                }
                            });

                            let maxAlphaWins = -1;
                            Object.values(alphaSoupScores).forEach(s => { if (s > maxAlphaWins) maxAlphaWins = s; });

                            let winners = maxAlphaWins > 0 ? Object.keys(alphaSoupScores).filter(n => alphaSoupScores[n] === maxAlphaWins) : [];

                            calculatedBadges.push({
                                emoji: "ü•´",
                                title: "Alphabet Soup",
                                winners: winners,
                                description: `A to Z strategy. Most wins (${maxAlphaWins}) when picking the team that comes first alphabetically.`,
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });

                        } catch (e) {
                            console.error("Alphabet Soup Error", e);
                            calculatedBadges.push({
                                emoji: "ü•´",
                                title: "Alphabet Soup",
                                winners: [],
                                description: "A to Z strategy. Most wins picking the team that comes first alphabetically.",
                                colorTheme: { bg: "bg-red-50", text: "text-red-900", border: "border-red-200" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 22: SHORT AND SWEET
                        // Most wins picking the team with the shorter name
                        // ----------------------------------------------------
                        try {
                            const shortScores = {};
                            picks.forEach(p => shortScores[p.Name] = 0);

                            // Helper to clean name (remove #12 etc)
                            const cleanName = (name) => name.replace(/#\d+\s*/g, '').trim();

                            schedule.forEach(game => {
                                if (!game.Winner || !game["Team 1"] || !game["Team 2"]) return;

                                const t1Raw = game["Team 1"];
                                const t2Raw = game["Team 2"];
                                const t1Clean = cleanName(t1Raw);
                                const t2Clean = cleanName(t2Raw);

                                let shortTeam = null;
                                if (t1Clean.length < t2Clean.length) {
                                    shortTeam = t1Raw;
                                } else if (t2Clean.length < t1Clean.length) {
                                    shortTeam = t2Raw;
                                }
                                // If lengths are equal, neither is shorter

                                // Only counts if the shorter name team actually won
                                if (shortTeam && game.Winner.toLowerCase() === shortTeam.toLowerCase()) {
                                     picks.forEach(p => {
                                         const pick = p[game.Bowl];
                                         if (pick && pick.toLowerCase() === shortTeam.toLowerCase()) {
                                             shortScores[p.Name]++;
                                         }
                                     });
                                }
                            });

                            let maxShortWins = -1;
                            Object.values(shortScores).forEach(s => { if (s > maxShortWins) maxShortWins = s; });

                            let winners = maxShortWins > 0 ? Object.keys(shortScores).filter(n => shortScores[n] === maxShortWins) : [];

                            calculatedBadges.push({
                                emoji: "üç¨",
                                title: "Short & Sweet",
                                winners: winners,
                                description: `Efficiency is key. Most wins (${maxShortWins}) picking the team with the shorter name.`,
                                colorTheme: { bg: "bg-teal-100", text: "text-teal-800", border: "border-teal-300" }
                            });

                        } catch (e) {
                            console.error("Short and Sweet Error", e);
                             calculatedBadges.push({
                                emoji: "üç¨",
                                title: "Short & Sweet",
                                winners: [],
                                description: "Efficiency is key. Most wins picking the team with the shorter name.",
                                colorTheme: { bg: "bg-teal-100", text: "text-teal-800", border: "border-teal-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 23: BOOKED A TEE TIME
                        // Most losses by an individual
                        // ----------------------------------------------------
                        try {
                            const playerLosses = {};
                            picks.forEach(p => playerLosses[p.Name] = 0);

                            schedule.forEach(g => {
                                if (g.Winner) {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        // Count as loss if pick exists but is wrong, or if pick is missing
                                        if (!pick || pick.toLowerCase() !== g.Winner.toLowerCase()) {
                                            playerLosses[p.Name]++;
                                        }
                                    });
                                }
                            });

                            let maxLosses = -1;
                            Object.values(playerLosses).forEach(l => { if (l > maxLosses) maxLosses = l; });

                            let winners = maxLosses > 0 ? Object.keys(playerLosses).filter(n => playerLosses[n] === maxLosses) : [];

                            calculatedBadges.push({
                                emoji: "‚õ≥Ô∏è",
                                title: "Booked a Tee Time",
                                winners: winners,
                                description: `It's just as hard to pick the wrong ones. Most losses (${maxLosses}).`,
                                colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                            });

                        } catch (e) {
                            console.error("Golf Error", e);
                             calculatedBadges.push({
                                emoji: "‚õ≥Ô∏è",
                                title: "Booked a Tee Time",
                                winners: [],
                                description: "It's just as hard to pick the wrong ones. Most losses.",
                                colorTheme: { bg: "bg-green-100", text: "text-green-800", border: "border-green-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 24: CHASING GLORY
                        // Most wins by a player who has not won a championship
                        // ----------------------------------------------------
                        try {
                            // 1. Identify Past Winners
                            const pastWinners = new Set();
                            history.forEach(h => {
                                if (h.Winner) pastWinners.add(h.Winner.trim().toLowerCase());
                            });

                            // 2. Calculate Current Standings
                            const currentWins = {};
                            picks.forEach(p => currentWins[p.Name] = 0);

                            schedule.forEach(g => {
                                if (g.Winner) {
                                    picks.forEach(p => {
                                        const pick = p[g.Bowl];
                                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                            currentWins[p.Name]++;
                                        }
                                    });
                                }
                            });

                            // 3. Find Max Wins among Non-Winners
                            let maxNonChampWins = -1;
                            let gloryHunters = [];

                            Object.keys(currentWins).forEach(player => {
                                if (!pastWinners.has(player.toLowerCase())) {
                                    const wins = currentWins[player];
                                    if (wins > maxNonChampWins) {
                                        maxNonChampWins = wins;
                                        gloryHunters = [player];
                                    } else if (wins === maxNonChampWins) {
                                        gloryHunters.push(player);
                                    }
                                }
                            });

                            if (maxNonChampWins > -1) {
                                calculatedBadges.push({
                                    emoji: "‚≠êÔ∏è",
                                    title: "Chasing Glory",
                                    winners: gloryHunters,
                                    description: `Hungry for the first title. Most wins (${maxNonChampWins}) by a player who has never won it all.`,
                                    colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                                });
                            }

                        } catch (e) {
                            console.error("Chasing Glory Error", e);
                            calculatedBadges.push({
                                emoji: "‚≠êÔ∏è",
                                title: "Chasing Glory",
                                winners: [],
                                description: "Hungry for the first title. Most wins by a player who has never won it all.",
                                colorTheme: { bg: "bg-yellow-100", text: "text-yellow-800", border: "border-yellow-300" }
                            });
                        }

                        // ----------------------------------------------------
                        // BADGE 25: BLIND FAITH
                        // Most correct picks on Unranked Teams
                        // ----------------------------------------------------
                        try {
                            const unrankedWins = {};
                            picks.forEach(p => unrankedWins[p.Name] = 0);

                            schedule.forEach(g => {
                                if (!g.Winner) return;
                                // Check if winner is unranked (no #)
                                if (!g.Winner.includes('#')) {
                                     picks.forEach(p => {
                                         const pick = p[g.Bowl];
                                         if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                                             unrankedWins[p.Name]++;
                                         }
                                     });
                                }
                            });

                            let maxUnranked = -1;
                            Object.values(unrankedWins).forEach(c => { if(c > maxUnranked) maxUnranked = c; });

                            let winners = maxUnranked > 0 ? Object.keys(unrankedWins).filter(n => unrankedWins[n] === maxUnranked) : [];

                            calculatedBadges.push({
                                emoji: "üôà",
                                title: "Blind Faith",
                                winners: winners,
                                description: `Who needs rankings? Most wins (${maxUnranked}) picking unranked teams.`,
                                colorTheme: { bg: "bg-stone-100", text: "text-stone-800", border: "border-stone-300" }
                            });

                        } catch (e) {
                            console.error("Blind Faith Error", e);
                            calculatedBadges.push({
                                emoji: "üôà",
                                title: "Blind Faith",
                                winners: [],
                                description: "Who needs rankings? Most wins picking unranked teams.",
                                colorTheme: { bg: "bg-stone-100", text: "text-stone-800", border: "border-stone-300" }
                            });
                        }

                        // Combine Calculated + Mocks
                        const finalPool = [...calculatedBadges, ...MOCK_BADGES];

                        // Assign static colors (if not already set) and shuffle once
                        const withColors = finalPool.map((badge, idx) => {
                            if (badge.colorTheme) return badge; // Use explicit theme if set
                            return {
                                ...badge,
                                colorTheme: THEMES[idx % THEMES.length]
                            };
                        });

                        // Shuffle
                        setBadges(withColors.sort(() => 0.5 - Math.random()));
                        setLoading(false);

                    } catch (err) {
                        console.error("Error init badges:", err);
                        setLoading(false);
                    }
                };
                init();
            }, [THEMES]);

            if (loading) return <LoadingSpinner text="Calculating Superlatives..." />;

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-8 px-4">
                        <div className="max-w-7xl mx-auto text-center">
                            <h2 className="text-3xl text-blue-900 font-bold mb-1">Superlatives</h2>
                            <p className="text-gray-600 text-sm">Celebrating the best, worst, and weirdest performances.</p>
                        </div>
                    </div>
                    <div className="px-4 md:px-6 max-w-7xl mx-auto w-full">
                         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {badges.map((badge, idx) => (
                                <BadgeCard
                                    key={idx}
                                    {...badge}
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // 5. VERSUS PAGE
        const VersusPage = () => {
            const [players, setPlayers] = useState([]);
            const [schedule, setSchedule] = useState([]);
            const [picks, setPicks] = useState([]);
            const [selectedP1, setSelectedP1] = useState("");
            const [selectedP2, setSelectedP2] = useState("");
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const init = async () => {
                    try {
                        const [scheduleRes, picksRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL)
                        ]);
                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();

                        const scheduleData = csvToJson(scheduleText);
                        const sortedSchedule = scheduleData
                            .filter(g => g.Date && g.Time)
                            .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                        const picksData = csvToJson(picksText).filter(p => p.Name);

                        setSchedule(sortedSchedule);
                        setPicks(picksData);

                        const names = picksData.map(p => p.Name).sort();
                        setPlayers(names);

                        if (names.length >= 2) {
                            // Randomize initial selection
                            let idx1 = Math.floor(Math.random() * names.length);
                            let idx2 = Math.floor(Math.random() * names.length);

                            // Ensure they are different
                            while (idx1 === idx2) {
                                idx2 = Math.floor(Math.random() * names.length);
                            }

                            setSelectedP1(names[idx1]);
                            setSelectedP2(names[idx2]);
                        }
                        setLoading(false);
                    } catch (e) {
                        console.error(e);
                        setLoading(false);
                    }
                };
                init();
            }, []);

            if (loading) return <LoadingSpinner text="Loading Rivalry Mode..." />;

            const getStats = (playerName) => {
                const p = picks.find(x => x.Name === playerName);
                if (!p) return { wins: 0, losses: 0, streak: 0 };
                let wins = 0; let losses = 0; let currentStreak = 0;
                schedule.forEach(g => {
                    if (g.Winner) {
                        const pick = p[g.Bowl];
                        if (pick && pick.toLowerCase() === g.Winner.toLowerCase()) {
                            wins++;
                            currentStreak = currentStreak >= 0 ? currentStreak + 1 : 1;
                        } else {
                            losses++;
                            currentStreak = currentStreak <= 0 ? currentStreak - 1 : -1;
                        }
                    }
                });
                return { wins, losses, streak: currentStreak };
            };

            const stats1 = getStats(selectedP1);
            const stats2 = getStats(selectedP2);
            const diffGames = [];
            const historyGames = [];
            let headToHead = { p1: 0, p2: 0 };

            if (selectedP1 && selectedP2) {
                const p1Data = picks.find(x => x.Name === selectedP1);
                const p2Data = picks.find(x => x.Name === selectedP2);
                schedule.forEach(g => {
                    const pick1 = p1Data[g.Bowl];
                    const pick2 = p2Data[g.Bowl];
                    if (pick1 && pick2 && pick1.toLowerCase() !== pick2.toLowerCase()) {
                        if (g.Winner) {
                            let winner = null;
                            if (pick1.toLowerCase() === g.Winner.toLowerCase()) { headToHead.p1++; winner = selectedP1; }
                            else if (pick2.toLowerCase() === g.Winner.toLowerCase()) { headToHead.p2++; winner = selectedP2; }
                            historyGames.push({ ...g, pick1, pick2, winner });
                        } else {
                            diffGames.push({ ...g, pick1, pick2 });
                        }
                    }
                });
            }

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-4 px-4">
                        <div className="max-w-4xl mx-auto text-center">
                            <h2 className="text-3xl text-blue-900 font-bold mb-1">Rivalry Mode</h2>
                            <p className="text-gray-600 text-sm">Sibling rivalries? Settle the score.</p>
                        </div>
                    </div>

                    <div className="px-4 max-w-4xl mx-auto w-full flex flex-col gap-6">

                        <div className="flex items-center justify-center gap-4 bg-gray-50 p-4 rounded-xl border border-gray-200 shadow-sm">
                            <select
                                value={selectedP1}
                                onChange={(e) => setSelectedP1(e.target.value)}
                                className="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 font-bold"
                            >
                                {players.map(p => <option key={p} value={p}>{p}</option>)}
                            </select>
                            <span className="text-gray-400 font-black italic">VS</span>
                            <select
                                value={selectedP2}
                                onChange={(e) => setSelectedP2(e.target.value)}
                                className="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 font-bold"
                            >
                                {players.map(p => <option key={p} value={p}>{p}</option>)}
                            </select>
                        </div>

                        <div className="bg-slate-900 text-white rounded-xl shadow-lg p-6 text-center relative overflow-hidden">
                             <div className="absolute top-0 right-0 w-32 h-32 bg-blue-500/20 rounded-full blur-3xl -mr-10 -mt-10 pointer-events-none"></div>
                             <div className="absolute bottom-0 left-0 w-32 h-32 bg-red-500/20 rounded-full blur-3xl -ml-10 -mb-10 pointer-events-none"></div>

                            <h3 className="text-xs font-bold uppercase tracking-widest text-slate-400 mb-4 relative z-10">Head-to-Head (Differing Picks)</h3>
                            <div className="flex items-center justify-center gap-8 md:gap-16 relative z-10">
                                <div className="text-center">
                                    <div className="text-4xl md:text-6xl font-black">{headToHead.p1}</div>
                                    <div className="text-xs font-bold text-slate-400 mt-1">{selectedP1}</div>
                                </div>
                                <div className="text-2xl text-slate-600 font-serif italic">-</div>
                                <div className="text-center">
                                    <div className="text-4xl md:text-6xl font-black">{headToHead.p2}</div>
                                    <div className="text-xs font-bold text-slate-400 mt-1">{selectedP2}</div>
                                </div>
                            </div>
                        </div>

                        {/* Tale of the Tape */}
                        <div className="grid grid-cols-2 gap-4">
                            <div className="bg-white border border-gray-100 shadow-md rounded-xl p-4 text-center">
                                <div className="text-xs text-gray-400 font-bold uppercase mb-1">Total Wins</div>
                                <div className="text-2xl font-black text-gray-900">{stats1.wins}</div>
                            </div>
                            <div className="bg-white border border-gray-100 shadow-md rounded-xl p-4 text-center">
                                <div className="text-xs text-gray-400 font-bold uppercase mb-1">Total Wins</div>
                                <div className="text-2xl font-black text-gray-900">{stats2.wins}</div>
                            </div>

                            <div className="bg-white border border-gray-100 shadow-md rounded-xl p-4 text-center">
                                <div className="text-xs text-gray-400 font-bold uppercase mb-1">Current Streak</div>
                                <div className={`text-xl font-bold ${stats1.streak >= 0 ? 'text-green-600' : 'text-red-500'}`}>
                                    {stats1.streak > 0 ? `W${stats1.streak}` : `L${Math.abs(stats1.streak)}`}
                                </div>
                            </div>
                            <div className="bg-white border border-gray-100 shadow-md rounded-xl p-4 text-center">
                                <div className="text-xs text-gray-400 font-bold uppercase mb-1">Current Streak</div>
                                <div className={`text-xl font-bold ${stats2.streak >= 0 ? 'text-green-600' : 'text-red-500'}`}>
                                    {stats2.streak > 0 ? `W${stats2.streak}` : `L${Math.abs(stats2.streak)}`}
                                </div>
                            </div>
                        </div>

                        {/* History (Moved Up & Styled Green) */}
                        <div className="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden">
                            <div className="bg-green-50 border-b border-green-100 px-4 py-3">
                                <h3 className="text-lg font-bold text-green-900 font-serif">Battle History</h3>
                            </div>
                            {historyGames.length > 0 ? (
                                <div className="divide-y divide-gray-100">
                                    {historyGames.reverse().map((g, idx) => {
                                        const p1Won = g.winner === selectedP1;
                                        const p2Won = g.winner === selectedP2;
                                        return (
                                            <div key={idx} className="p-4 flex items-center justify-between">
                                                 <div className={`text-right w-1/3 ${p1Won ? 'opacity-100' : 'opacity-40 grayscale'}`}>
                                                    <div className={`font-bold text-sm leading-tight ${p1Won ? 'text-green-700' : 'text-gray-900'}`}>{g.pick1}</div>
                                                    {p1Won && <div className="text-[10px] font-black text-green-600 uppercase">Winner</div>}
                                                </div>
                                                <div className="px-2 text-center w-1/3">
                                                    <div className="text-[10px] font-bold text-gray-400 uppercase tracking-wide mb-0.5">{g.Bowl}</div>
                                                    <div className="text-xs text-gray-300 font-bold">FINAL</div>
                                                </div>
                                                <div className={`text-left w-1/3 ${p2Won ? 'opacity-100' : 'opacity-40 grayscale'}`}>
                                                    <div className={`font-bold text-sm leading-tight ${p2Won ? 'text-green-700' : 'text-gray-900'}`}>{g.pick2}</div>
                                                    {p2Won && <div className="text-[10px] font-black text-green-600 uppercase">Winner</div>}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="p-8 text-center text-gray-400 text-sm italic">
                                    No battles fought yet.
                                </div>
                            )}
                        </div>

                        {/* The Battleground (Moved Down) */}
                        <div className="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden mb-8">
                            <div className="bg-red-50 border-b border-red-100 px-4 py-3">
                                <h3 className="text-lg font-bold text-red-900 font-serif">The Battleground</h3>
                                <p className="text-xs text-red-700">Upcoming games where you picked differently.</p>
                            </div>
                            {diffGames.length > 0 ? (
                                <div className="divide-y divide-gray-100">
                                    {diffGames.map((g, idx) => (
                                        <div key={idx} className="p-4 flex items-center justify-between">
                                            <div className="text-right w-1/3">
                                                <div className="font-bold text-gray-900 text-sm leading-tight">{g.pick1}</div>
                                                <div className="text-[10px] text-gray-400 font-bold">{selectedP1}</div>
                                            </div>
                                            <div className="px-2 text-center w-1/3">
                                                <div className="text-[10px] font-bold text-gray-400 uppercase tracking-wide mb-0.5">{g.Bowl}</div>
                                                <div className="text-xs font-medium text-red-500 bg-red-50 px-2 py-0.5 rounded-full inline-block">vs</div>
                                            </div>
                                            <div className="text-left w-1/3">
                                                <div className="font-bold text-gray-900 text-sm leading-tight">{g.pick2}</div>
                                                <div className="text-[10px] text-gray-400 font-bold">{selectedP2}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="p-8 text-center text-gray-400 text-sm italic">
                                    No upcoming battles. You agree on everything!
                                </div>
                            )}
                        </div>

                    </div>
                </div>
            );
        };

        // 6. SIMULATOR PAGE (NEW)
        const SimulatorPage = () => {
            const [loading, setLoading] = useState(true);
            const [schedule, setSchedule] = useState([]);
            const [picks, setPicks] = useState([]);
            const [simulatedWinners, setSimulatedWinners] = useState({});

            useEffect(() => {
                const init = async () => {
                    try {
                        const [scheduleRes, picksRes] = await Promise.all([
                            fetch(SCHEDULE_URL),
                            fetch(PICKS_URL)
                        ]);
                        const scheduleText = await scheduleRes.text();
                        const picksText = await picksRes.text();

                        const scheduleData = csvToJson(scheduleText);
                        // Filter for UNPLAYED games (no winner yet) for the toggles
                        const unplayed = scheduleData.filter(g => !g.Winner && g.Bowl && g["Team 1"]);
                        // Sort by date/time
                        unplayed.sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                        const picksData = csvToJson(picksText).filter(p => p.Name);

                        setSchedule(scheduleData); // Need full schedule for calculations
                        setPicks(picksData);
                        setLoading(false);
                    } catch (e) {
                        console.error(e);
                        setLoading(false);
                    }
                };
                init();
            }, []);

            const toggleWinner = (bowl, team) => {
                setSimulatedWinners(prev => {
                    const next = { ...prev };
                    if (next[bowl] === team) {
                        delete next[bowl]; // Toggle off if already selected
                    } else {
                        next[bowl] = team;
                    }
                    return next;
                });
            };

            const resetSimulation = () => {
                setSimulatedWinners({});
            };

            // Calculate Projected Standings based on REAL winners + SIMULATED winners
            const projectedStandings = useMemo(() => {
                if (picks.length === 0) return [];

                return picks.map(player => {
                    let wins = 0;
                    schedule.forEach(game => {
                        const realWinner = game.Winner;
                        const simWinner = simulatedWinners[game.Bowl];

                        // Use simulated winner if no real winner exists
                        const winnerToUse = realWinner || simWinner;

                        if (winnerToUse) {
                            const pick = player[game.Bowl];
                            if (pick && pick.toLowerCase() === winnerToUse.toLowerCase()) {
                                wins++;
                            }
                        }
                    });
                    return { name: player.Name, wins };
                }).sort((a, b) => b.wins - a.wins); // Sort descending
            }, [picks, schedule, simulatedWinners]);

            if (loading) return <LoadingSpinner text="Booting up The Oracle..." />;

            const unplayedGames = schedule.filter(g => !g.Winner && g.Bowl && g["Team 1"]).sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-4 px-4">
                        <div className="max-w-4xl mx-auto text-center">
                            <h2 className="text-3xl text-blue-900 font-bold mb-1">The Simulator</h2>
                            <p className="text-gray-600 text-sm">Choose your destiny and predict the future.</p>
                        </div>
                    </div>

                    {/* Projected Leaderboard (Sticky) */}
                    <div className="sticky top-16 z-40 bg-white/95 backdrop-blur-sm border-b border-gray-100 shadow-sm px-4 pb-2 pt-2">
                        <div className="bg-slate-900 text-white rounded-xl p-4 shadow-lg mb-2">
                             <div className="flex justify-between items-center mb-2">
                                <h3 className="text-xs font-bold uppercase tracking-widest text-yellow-400">Projected Leaderboard</h3>
                                <button onClick={resetSimulation} className="text-[10px] bg-white/10 hover:bg-white/20 px-2 py-1 rounded text-white font-bold transition-colors">Reset All</button>
                             </div>
                             <div className="overflow-x-auto no-scrollbar pb-2">
                                 <div className="flex gap-4 w-fit mx-auto">
                                     {projectedStandings.slice(0, 10).map((p, idx) => (
                                         <div key={p.name} className="flex flex-col items-center justify-center flex-shrink-0 w-16">
                                             <span className="text-2xl font-black w-full text-center">{p.wins}</span>
                                             <span className="text-[10px] font-bold text-slate-400 truncate w-full text-center">{p.name}</span>
                                         </div>
                                     ))}
                                 </div>
                             </div>
                        </div>
                    </div>

                    <div className="px-4 max-w-4xl mx-auto w-full pt-4 pb-8 space-y-4">
                         {unplayedGames.length === 0 ? (
                             <div className="text-center text-gray-500 py-12">No unplayed games left to simulate!</div>
                         ) : (
                             unplayedGames.map((game) => {
                                 const selected = simulatedWinners[game.Bowl];
                                 return (
                                    <div key={game.Bowl} className="bg-white border border-gray-200 rounded-xl shadow-sm overflow-hidden">
                                        <div className="bg-gray-50 px-4 py-2 border-b border-gray-100 flex justify-between items-center">
                                            <span className="text-xs font-bold text-gray-500 uppercase tracking-wide">{game.Bowl}</span>
                                            <span className="text-[10px] font-bold text-gray-400">{game.Date}</span>
                                        </div>
                                        <div className="p-4 flex items-center justify-between gap-4">
                                            <button
                                                onClick={() => toggleWinner(game.Bowl, game["Team 1"])}
                                                className={`flex-1 py-3 px-2 rounded-lg font-bold text-sm transition-all border-2 ${selected === game["Team 1"] ? 'bg-green-600 text-white border-green-600 shadow-md transform scale-[1.02]' : 'bg-white text-gray-700 border-gray-200 hover:border-green-300'}`}
                                            >
                                                {game["Team 1"]}
                                            </button>
                                            <span className="text-gray-300 font-serif italic text-xs">vs</span>
                                             <button
                                                onClick={() => toggleWinner(game.Bowl, game["Team 2"])}
                                                className={`flex-1 py-3 px-2 rounded-lg font-bold text-sm transition-all border-2 ${selected === game["Team 2"] ? 'bg-green-600 text-white border-green-600 shadow-md transform scale-[1.02]' : 'bg-white text-gray-700 border-gray-200 hover:border-green-300'}`}
                                            >
                                                {game["Team 2"]}
                                            </button>
                                        </div>
                                    </div>
                                 );
                             })
                         )}
                    </div>
                </div>
            );
        };

        // 7. SCOUTING REPORT PAGE
        const ScoutingReportPage = () => {
            const [selectedPlayer, setSelectedPlayer] = useState("");
            const [players, setPlayers] = useState([]);
            const [schedule, setSchedule] = useState([]);
            const [picks, setPicks] = useState([]);
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const init = async () => {
                    try {
                        const [schedRes, picksRes, histRes] = await Promise.all([
                            fetch(SCHEDULE_URL), fetch(PICKS_URL), fetch(HISTORY_URL)
                        ]);
                        const schedText = await schedRes.text();
                        const picksText = await picksRes.text();
                        const histText = await histRes.text();

                        const sData = csvToJson(schedText);
                        const pData = csvToJson(picksText).filter(p => p.Name);
                        const hData = csvToJson(histText);

                        setSchedule(sData);
                        setPicks(pData);
                        setHistory(hData);

                        const names = pData.map(p => p.Name).sort();
                        setPlayers(names);
                        if (names.length > 0) setSelectedPlayer(names[0]);

                        setLoading(false);
                    } catch (e) { console.error(e); setLoading(false); }
                };
                init();
            }, []);

            if (loading) return <LoadingSpinner text="Scouting players..." />;

            // --- CALCULATIONS ---
                        const calculateStats = (player) => {
                            if (!player) return null;
                            const pData = picks.find(p => p.Name === player);
                            if (!pData) return null;

                            // 1. Current Rank & Wins
                            const leaderboard = picks.map(p => {
                                let w = 0;
                                schedule.forEach(g => {
                                    if (g.Winner && p[g.Bowl] && p[g.Bowl].toLowerCase() === g.Winner.toLowerCase()) w++;
                                });
                                return { name: p.Name, wins: w };
                            }).sort((a,b) => b.wins - a.wins);

                            // Calculate Rank with Ties logic
                            let currentRank = 1;
                            for (let i = 0; i < leaderboard.length; i++) {
                                // If this player has fewer wins than the previous one, update the rank to current index + 1
                                if (i > 0 && leaderboard[i].wins < leaderboard[i - 1].wins) {
                                    currentRank = i + 1;
                                }
                                leaderboard[i].rank = currentRank;

                                // Check if they are tied with someone else
                                // A tie exists if the player above OR below has the same win count
                                const prev = leaderboard[i-1];
                                const next = leaderboard[i+1];
                                leaderboard[i].isTied = (prev && prev.wins === leaderboard[i].wins) || (next && next.wins === leaderboard[i].wins);
                            }

                            const playerEntry = leaderboard.find(p => p.name === player);
                            const rank = playerEntry.rank;
                            const wins = playerEntry.wins;
                            const isTied = playerEntry.isTied;

                            // 2. Past Greatness (History)
                            const pastWinsData = history.filter(h => h.Winner && h.Winner.trim().toLowerCase() === player.toLowerCase());
                            const titles = pastWinsData.length;
                            const titleYears = pastWinsData.map(h => h.Year).sort().join(', ');

                            // 3. Situationals
                            const getWinStats = (filterFn) => {
                                const games = schedule.filter(g => g.Winner && filterFn(g));
                                if (games.length === 0) return { pct: 0, wins: 0, total: 0 };
                                let w = 0;
                                games.forEach(g => {
                                    if (pData[g.Bowl] && pData[g.Bowl].toLowerCase() === g.Winner.toLowerCase()) w++;
                                });
                                return { pct: Math.round((w / games.length) * 100), wins: w, total: games.length };
                            };

                            const getTimeHour = (g) => {
                                if (!g.Time) return null;
                                const timeStr = g.Time.trim().toUpperCase();
                                let [timePart, modifier] = timeStr.split(' ');
                                if (!modifier) {
                                     if (timeStr.includes('PM')) { modifier = 'PM'; timePart = timeStr.replace('PM',''); }
                                     else if (timeStr.includes('AM')) { modifier = 'AM'; timePart = timeStr.replace('AM',''); }
                                }
                                let [hours, minutes] = timePart.split(':').map(Number);
                                if (modifier === 'PM' && hours !== 12) hours += 12;
                                if (modifier === 'AM' && hours === 12) hours = 0;
                                return hours;
                            };

                            const cfp = getWinStats(g => g.CFP);
                            const b1g = getWinStats(g => g.B1G);
                            const sec = getWinStats(g => g.SEC);

                            const morning = getWinStats(g => {
                                const h = getTimeHour(g);
                                return h !== null && h < 12;
                            });
                            const afternoon = getWinStats(g => {
                                const h = getTimeHour(g);
                                return h !== null && h >= 12 && h < 19;
                            });
                            const night = getWinStats(g => {
                                const h = getTimeHour(g);
                                return h !== null && h >= 19;
                            });

                            const espn = getWinStats(g => g.Network && g.Network.toUpperCase().includes('ESPN'));
                            const abc = getWinStats(g => g.Network && g.Network.toUpperCase().includes('ABC'));
                            const fox = getWinStats(g => g.Network && g.Network.toUpperCase().includes('FOX'));
                            const cbs = getWinStats(g => g.Network && g.Network.toUpperCase().includes('CBS'));
                            const tnt = getWinStats(g => g.Network && g.Network.toUpperCase().includes('TNT'));

                            // 4. Maverick Rating
                            let maverickScore = 0;
                            let totalGames = 0;
                            schedule.forEach(g => {
                                if (!g.Bowl) return;
                                const myPick = pData[g.Bowl];
                                if (!myPick) return;

                                const counts = {};
                                picks.forEach(p => {
                                    const pp = p[g.Bowl];
                                    if (pp) counts[pp] = (counts[pp] || 0) + 1;
                                });
                                let maxC = 0; let majority = null;
                                Object.entries(counts).forEach(([pick, count]) => {
                                    if (count > maxC) { maxC = count; majority = pick; }
                                });

                                totalGames++;
                                if (myPick !== majority) maverickScore++;
                            });
                            const maverickPct = totalGames > 0 ? Math.round((maverickScore / totalGames) * 100) : 0;

                            // 5. Nemesis & BFF
                            let maxDiff = -1; let nemesis = "-";
                            let maxSame = -1; let bff = "-";

                            picks.forEach(p => {
                                if (p.Name === player) return;
                                let diff = 0; let same = 0;
                                schedule.forEach(g => {
                                    const myP = pData[g.Bowl];
                                    const theirP = p[g.Bowl];
                                    if (myP && theirP) {
                                        if (myP !== theirP) diff++;
                                        else same++;
                                    }
                                });
                                if (diff > maxDiff) { maxDiff = diff; nemesis = p.Name; }
                                if (same > maxSame) { maxSame = same; bff = p.Name; }
                            });

                            // 6. Streaks Calculation
                            const completedGames = schedule
                                .filter(g => g.Winner && g.Date && g.Time)
                                .sort((a, b) => new Date(`${a.Date} ${a.Time}`) - new Date(`${b.Date} ${b.Time}`));

                            let currentStreak = 0;
                            let maxWinStreak = 0;
                            let maxLossStreak = 0;
                            let tempWin = 0;
                            let tempLoss = 0;

                            completedGames.forEach(g => {
                                const pick = pData[g.Bowl];
                                const winner = g.Winner;

                                if (pick && pick.toLowerCase() === winner.toLowerCase()) {
                                    tempWin++;
                                    if (tempWin > maxWinStreak) maxWinStreak = tempWin;
                                    tempLoss = 0;
                                    currentStreak = currentStreak >= 0 ? currentStreak + 1 : 1;
                                } else {
                                    tempLoss++;
                                    if (tempLoss > maxLossStreak) maxLossStreak = tempLoss;
                                    tempWin = 0;
                                    currentStreak = currentStreak <= 0 ? currentStreak - 1 : -1;
                                }
                            });

                            // 7. Ceiling Tracker Logic
                            const totalGameCount = schedule.filter(g => g.Bowl && g["Team 1"]).length;
                            const unplayedCount = schedule.filter(g => g.Bowl && g["Team 1"] && !g.Winner).length;
                            const maxPotential = wins + unplayedCount;
                            const leaderWins = Math.max(...leaderboard.map(p => p.wins));

                            // 8. Signature Win Logic
                            let bestWin = null;
                            let minWinners = Infinity;

                            schedule.forEach(g => {
                                if (!g.Winner) return;
                                const myPick = pData[g.Bowl];
                                if (myPick && myPick.toLowerCase() === g.Winner.toLowerCase()) {
                                    let gameWinnerCount = 0;
                                    picks.forEach(p => {
                                        const theirPick = p[g.Bowl];
                                        if (theirPick && theirPick.toLowerCase() === g.Winner.toLowerCase()) {
                                            gameWinnerCount++;
                                        }
                                    });

                                    if (gameWinnerCount < minWinners) {
                                        minWinners = gameWinnerCount;
                                        bestWin = {
                                            bowl: g.Bowl,
                                            team: g.Winner,
                                            count: gameWinnerCount
                                        };
                                    }
                                }
                            });

                            return { rank, isTied, wins, titles, titleYears, cfp, b1g, sec, morning, afternoon, night, espn, abc, fox, cbs, tnt, maverickPct, nemesis, bff,
                                     champ: pData["National Championship"], tiebreaker: pData["Tiebreaker Score"],
                                     currentStreak, maxWinStreak, maxLossStreak,
                                     maxPotential, totalGameCount, leaderWins, bestWin };
                        };

                        const stats = calculateStats(selectedPlayer);

                        return (
                            <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                                 <div className="bg-white pt-8 pb-4 px-4">
                                    <div className="max-w-4xl mx-auto text-center">
                                        <h2 className="text-3xl text-blue-900 font-bold mb-1">Scouting Report</h2>
                                        <p className="text-gray-600 text-sm">Deep dive analytics into your favorite people.</p>
                                    </div>
                                </div>

                                <div className="px-4 max-w-xl mx-auto w-full flex flex-col gap-6">
                                    {/* Selector */}
                                    <div className="relative">
                                        <select
                                            value={selectedPlayer}
                                            onChange={(e) => setSelectedPlayer(e.target.value)}
                                            className="appearance-none bg-white border border-gray-300 text-gray-900 text-lg rounded-xl focus:ring-blue-500 focus:border-blue-500 block w-full p-4 font-bold shadow-sm text-center"
                                        >
                                            {players.map(p => <option key={p} value={p}>{p}</option>)}
                                        </select>
                                        <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-500">
                                            <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                                        </div>
                                    </div>

                                    {stats && (
                                        <>
                                            {/* Top Card */}
                                            <div className="bg-slate-900 text-white rounded-2xl p-6 shadow-xl relative overflow-hidden">
                                                <div className="absolute top-0 right-0 w-32 h-32 bg-blue-500/20 rounded-full blur-3xl -mr-10 -mt-10 pointer-events-none"></div>
                                                <div className="flex justify-between items-center mb-6 relative z-10">
                                                    <div className="text-left">
                                                        <div className="text-sm text-slate-400 font-bold uppercase tracking-widest">Current Rank</div>
                                                        <div className="text-5xl font-black text-white">
                                                            {stats.isTied ? "T-" : ""}{stats.rank}
                                                        </div>
                                                    </div>
                                                    <div className="text-right">
                                                        <div className="text-sm text-slate-400 font-bold uppercase tracking-widest">Wins</div>
                                                        <div className="text-5xl font-black text-yellow-400">{stats.wins}</div>
                                                    </div>
                                                </div>

                                    {/* PAST GREATNESS BADGE */}
                                    {stats.titles > 0 ? (
                                        <div className="bg-gradient-to-r from-yellow-500/20 to-amber-500/20 border border-yellow-500/30 rounded-lg p-3 flex items-center gap-3 relative z-10">
                                            <div className="text-2xl">üèÜ</div>
                                            <div>
                                                <div className="text-xs font-bold text-yellow-400 uppercase tracking-widest">Past Greatness</div>
                                                <div className="text-white font-bold">
                                                    {stats.titles}-Time Champion <span className="text-yellow-200/70 text-xs font-normal ml-1">({stats.titleYears})</span>
                                                </div>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="bg-white/5 border border-white/10 rounded-lg p-3 flex items-center gap-3 relative z-10 opacity-50">
                                            <div className="text-2xl grayscale">üèÜ</div>
                                            <div>
                                                <div className="text-xs font-bold text-slate-400 uppercase tracking-widest">Past Greatness</div>
                                                <div className="text-slate-300 font-bold text-sm">Chasing first title</div>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Ceiling Tracker */}
                                <div className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                                    <div className="bg-gray-50 border-b border-gray-200 px-4 py-3 flex justify-between items-center">
                                        <h3 className="text-lg font-bold text-gray-900 font-serif">Ceiling Tracker</h3>
                                        <span className="text-sm font-bold text-blue-600">{stats.maxPotential} Max Wins</span>
                                    </div>
                                    <div className="p-5">
                                        <div className="relative h-6 bg-gray-100 rounded-full w-full overflow-hidden mb-2">
                                            {/* Current Wins */}
                                            <div
                                                className="absolute top-0 bottom-0 left-0 bg-blue-600 transition-all duration-1000 z-10"
                                                style={{ width: `${(stats.wins / stats.totalGameCount) * 100}%` }}
                                            ></div>
                                            {/* Potential Wins */}
                                            <div
                                                className="absolute top-0 bottom-0 left-0 bg-blue-200 transition-all duration-1000"
                                                style={{ width: `${(stats.maxPotential / stats.totalGameCount) * 100}%` }}
                                            ></div>
                                            {/* Leader Line */}
                                            <div
                                                className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-20 shadow-[0_0_8px_rgba(239,68,68,0.6)]"
                                                style={{ left: `${(stats.leaderWins / stats.totalGameCount) * 100}%` }}
                                            ></div>
                                        </div>
                                        <div className="flex justify-between text-xs font-bold text-gray-400 uppercase tracking-wide">
                                            <span>Current: {stats.wins}</span>
                                            <span className="text-red-500">Leader: {stats.leaderWins}</span>
                                        </div>
                                    </div>
                                </div>

                                {/* Vitals Grid */}
                                <div className="grid grid-cols-2 gap-3">
                                    <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm">
                                        <div className="text-xs font-bold text-gray-400 uppercase mb-1">Champ Pick</div>
                                        <div className="text-lg font-black text-blue-900 truncate">{stats.champ}</div>
                                    </div>
                                    <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm">
                                        <div className="text-xs font-bold text-gray-400 uppercase mb-1">Tiebreaker</div>
                                        <div className="text-lg font-black text-blue-900">{stats.tiebreaker} pts</div>
                                    </div>
                                    <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm">
                                        <div className="flex justify-between items-center mb-1">
                                            <div className="text-xs font-bold text-gray-400 uppercase">Nemesis</div>
                                        </div>
                                        <div className="text-lg font-black text-red-600 truncate">{stats.nemesis}</div>
                                        <div className="text-[10px] text-gray-500 mt-0.5">Most differing picks</div>
                                    </div>
                                    <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm">
                                        <div className="flex justify-between items-center mb-1">
                                            <div className="text-xs font-bold text-gray-400 uppercase">Best Friend</div>
                                        </div>
                                        <div className="text-lg font-black text-green-600 truncate">{stats.bff}</div>
                                        <div className="text-[10px] text-gray-500 mt-0.5">Most shared picks</div>
                                    </div>
                                </div>

                                {/* Streaks Card */}
                                <div className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                                    <div className="bg-gray-50 border-b border-gray-200 px-4 py-3">
                                        <h3 className="text-lg font-bold text-gray-900 font-serif">Season Streaks</h3>
                                    </div>
                                    <div className="p-4 grid grid-cols-3 gap-2 text-center divide-x divide-gray-100">
                                        <div>
                                            <div className="text-xs font-bold text-gray-400 uppercase mb-1">Current</div>
                                            <div className={`text-xl font-black ${stats.currentStreak > 0 ? 'text-green-600' : stats.currentStreak < 0 ? 'text-red-600' : 'text-gray-400'}`}>
                                                {stats.currentStreak > 0 ? `W${stats.currentStreak}` : stats.currentStreak < 0 ? `L${Math.abs(stats.currentStreak)}` : '-'}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-xs font-bold text-gray-400 uppercase mb-1">Longest Win</div>
                                            <div className="text-xl font-black text-green-600">
                                                W{stats.maxWinStreak}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-xs font-bold text-gray-400 uppercase mb-1">Longest Loss</div>
                                            <div className="text-xl font-black text-red-600">
                                                L{stats.maxLossStreak}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Signature Win Card */}
                                {stats.bestWin && (
                                    <div className="bg-gradient-to-br from-indigo-50 to-blue-50 rounded-xl border border-indigo-100 shadow-sm p-5 relative overflow-hidden">
                                        <div className="absolute top-0 right-0 text-6xl opacity-10 pointer-events-none">üåü</div>
                                        <h3 className="text-xs font-bold text-indigo-400 uppercase tracking-widest mb-1">Signature Win</h3>
                                        <div className="text-lg font-black text-indigo-900 leading-tight mb-2">
                                            Picked {stats.bestWin.team} in the {stats.bestWin.bowl}
                                        </div>
                                        <div className="inline-block bg-white border border-indigo-200 text-indigo-600 text-xs font-bold px-2 py-1 rounded shadow-sm">
                                            {stats.bestWin.count === 1
                                                ? "Only player to pick this!"
                                                : `Only ${stats.bestWin.count} players picked this`}
                                        </div>
                                    </div>
                                )}

                                {/* Skills Breakdown */}
                                <div className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                                    <div className="bg-gray-50 border-b border-gray-200 px-4 py-3">
                                        <h3 className="text-lg font-bold text-gray-900 font-serif">Performance Grades</h3>
                                    </div>
                                    <div className="p-5 space-y-4">
                                        <div>
                                            <div className="flex justify-between text-sm font-bold mb-1">
                                                <span className="text-yellow-700">Playoffs <span className="text-gray-400 font-normal ml-1">({stats.cfp.wins} of {stats.cfp.total})</span></span>
                                                <span className="text-yellow-900">{stats.cfp.pct}%</span>
                                            </div>
                                            <div className="w-full bg-gray-100 rounded-full h-2">
                                                <div className="bg-yellow-500 h-2 rounded-full" style={{ width: `${stats.cfp.pct}%` }}></div>
                                            </div>
                                        </div>
                                        <div>
                                            <div className="flex justify-between text-sm font-bold mb-1">
                                                <span className="text-indigo-900">Big Ten conference matchups <span className="text-gray-400 font-normal ml-1">({stats.b1g.wins} of {stats.b1g.total})</span></span>
                                                <span className="text-indigo-700">{stats.b1g.pct}%</span>
                                            </div>
                                            <div className="w-full bg-gray-100 rounded-full h-2">
                                                <div className="bg-indigo-500 h-2 rounded-full" style={{ width: `${stats.b1g.pct}%` }}></div>
                                            </div>
                                        </div>
                                        <div>
                                            <div className="flex justify-between text-sm font-bold mb-1">
                                                <span className="text-blue-900">SEC conference matchups <span className="text-gray-400 font-normal ml-1">({stats.sec.wins} of {stats.sec.total})</span></span>
                                                <span className="text-blue-700">{stats.sec.pct}%</span>
                                            </div>
                                            <div className="w-full bg-gray-100 rounded-full h-2">
                                                <div className="bg-blue-600 h-2 rounded-full" style={{ width: `${stats.sec.pct}%` }}></div>
                                            </div>
                                        </div>

                                        <div className="border-t border-gray-100 pt-4 space-y-4">
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-orange-900">Morning Games <span className="text-gray-400 font-normal ml-1">({stats.morning.wins} of {stats.morning.total})</span></span>
                                                    <span className="text-orange-700">{stats.morning.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-orange-400 h-2 rounded-full" style={{ width: `${stats.morning.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-sky-900">Afternoon Games <span className="text-gray-400 font-normal ml-1">({stats.afternoon.wins} of {stats.afternoon.total})</span></span>
                                                    <span className="text-sky-700">{stats.afternoon.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-sky-500 h-2 rounded-full" style={{ width: `${stats.afternoon.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-purple-900">Night Games <span className="text-gray-400 font-normal ml-1">({stats.night.wins} of {stats.night.total})</span></span>
                                                    <span className="text-purple-700">{stats.night.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-purple-600 h-2 rounded-full" style={{ width: `${stats.night.pct}%` }}></div>
                                                </div>
                                            </div>
                                        </div>

                                        <div className="border-t border-gray-100 pt-4 space-y-4">
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-red-900">ESPN <span className="text-gray-400 font-normal ml-1">({stats.espn.wins} of {stats.espn.total})</span></span>
                                                    <span className="text-red-700">{stats.espn.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-red-600 h-2 rounded-full" style={{ width: `${stats.espn.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-gray-900">ABC <span className="text-gray-400 font-normal ml-1">({stats.abc.wins} of {stats.abc.total})</span></span>
                                                    <span className="text-gray-700">{stats.abc.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-gray-900 h-2 rounded-full" style={{ width: `${stats.abc.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-blue-900">FOX <span className="text-gray-400 font-normal ml-1">({stats.fox.wins} of {stats.fox.total})</span></span>
                                                    <span className="text-blue-700">{stats.fox.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-blue-600 h-2 rounded-full" style={{ width: `${stats.fox.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-sky-900">CBS <span className="text-gray-400 font-normal ml-1">({stats.cbs.wins} of {stats.cbs.total})</span></span>
                                                    <span className="text-sky-700">{stats.cbs.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-sky-500 h-2 rounded-full" style={{ width: `${stats.cbs.pct}%` }}></div>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex justify-between text-sm font-bold mb-1">
                                                    <span className="text-pink-900">TNT <span className="text-gray-400 font-normal ml-1">({stats.tnt.wins} of {stats.tnt.total})</span></span>
                                                    <span className="text-pink-700">{stats.tnt.pct}%</span>
                                                </div>
                                                <div className="w-full bg-gray-100 rounded-full h-2">
                                                    <div className="bg-pink-600 h-2 rounded-full" style={{ width: `${stats.tnt.pct}%` }}></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Style Meter */}
                                <div className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                                    <div className="bg-gray-50 border-b border-gray-200 px-4 py-3">
                                        <h3 className="text-lg font-bold text-gray-900 font-serif">Style Rating</h3>
                                    </div>
                                    <div className="p-5">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-sm font-bold text-gray-400 uppercase">üêë Sheep</span>
                                            <span className="text-sm font-bold text-gray-400 uppercase">Maverick ü§†</span>
                                        </div>
                                        <div className="relative h-4 bg-gray-100 rounded-full w-full overflow-hidden">
                                            <div className="absolute top-0 bottom-0 left-0 bg-blue-500/20 w-full"></div>
                                            <div
                                                className="absolute top-0 bottom-0 bg-blue-600 w-2 rounded-full shadow-md transition-all duration-500"
                                                style={{ left: `${stats.maverickPct}%` }}
                                            ></div>
                                        </div>
                                        <div className="text-center mt-2 text-sm font-bold text-gray-500">
                                            {stats.maverickPct < 20 ? "Follows the Herd" : stats.maverickPct > 40 ? "Lone Wolf" : "Balanced Picker"} ({stats.maverickPct}%)
                                        </div>
                                        <p className="text-xs text-gray-400 text-center mt-3 px-2 leading-relaxed">
                                            This rating measures how often a player picks with the majority consensus (Sheep) versus picking against the group (Maverick). A lower percentage means you tend to agree with everyone else; a higher percentage means you like to go it alone.
                                        </p>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // 8. HISTORY PAGE
        const HistoryPage = () => {
            const [historyData, setHistoryData] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null);
            useEffect(() => {
                const fetchHistory = async () => {
                    try {
                        const response = await fetch(HISTORY_URL); if (!response.ok) throw new Error("Failed to fetch History data");
                        const text = await response.text(); const rawData = csvToJson(text);
                        const sortedAsc = rawData.filter(r => r.Year && r.Winner).sort((a, b) => parseInt(a.Year) - parseInt(b.Year));
                        const winCounts = {};
                        setHistoryData(sortedAsc.map(entry => {
                            const winner = entry.Winner.trim(); winCounts[winner] = (winCounts[winner] || 0) + 1;
                            return { ...entry, winNumber: winCounts[winner] };
                        }).reverse());
                    } catch (err) { console.error(err); setError(err.message); } finally { setLoading(false); }
                };
                fetchHistory();
            }, []);
            if (loading) return <LoadingSpinner text="Loading History..." />;
            if (error) return <ErrorMessage message={error} />;
            return (
                <div className="flex flex-col min-h-screen bg-white font-sans pb-24">
                    <div className="bg-white pt-8 pb-8 px-4"><div className="max-w-7xl mx-auto text-center"><h2 className="text-3xl text-blue-900 font-bold mb-1">Hall of Fame</h2><p className="text-gray-600 text-sm">The legends of the family pool.</p></div></div>
                    <div className="relative px-4 max-w-2xl mx-auto w-full"><div className="space-y-8">
                            {historyData.map((item, index) => (
                                <div key={index} className="relative flex items-center group">
                                    <div className="absolute left-6 md:left-8 -translate-x-1/2 w-10 h-10 md:w-12 md:h-12 bg-white border-4 border-blue-100 rounded-full flex items-center justify-center z-10 shadow-sm group-hover:scale-110 group-hover:border-yellow-400 transition-all duration-300">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-yellow-500"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
                                    </div>
                                    <div className="ml-16 md:ml-20 bg-white p-5 rounded-2xl shadow-sm border border-gray-100 w-full flex justify-between items-center relative overflow-hidden group-hover:shadow-md transition-shadow">
                                        <div className="absolute -right-2 -bottom-6 text-7xl md:text-8xl font-black text-gray-50 select-none z-0">{item.Year}</div>
                                        <div className="relative z-10"><div className="flex items-center gap-2 mb-1"><span className="text-xs font-bold text-blue-500 uppercase tracking-widest">Champion</span>{item.winNumber > 1 && (<span className="bg-yellow-100 text-yellow-700 text-[10px] font-black px-2 py-0.5 rounded-full uppercase tracking-wide border border-yellow-200 shadow-sm">{item.winNumber}-Time Winner</span>)}</div><h3 className="text-2xl md:text-3xl font-bold text-gray-800">{item.Winner}</h3></div>
                                        <div className="relative z-10 ml-4"><div className="bg-gray-50 px-3 py-1 md:px-4 md:py-2 rounded-lg border border-gray-100 text-center"><span className="text-lg md:text-xl font-bold text-blue-900 block leading-none">{item.Year}</span></div></div>
                                    </div>
                                </div>
                            ))}
                        </div></div>
                </div>
            );
        };

        const App = () => {
            const [activeTab, setActiveTab] = useState('home');
            return (
                <div className="min-h-screen bg-white pt-16">
                    <Navigation activeTab={activeTab} setActiveTab={setActiveTab} />
                    {activeTab === 'home' && <HomePage />}
                    {activeTab === 'standings' && <StandingsPage />}
                    {activeTab === 'picks' && <PicksPage />}
                    {activeTab === 'race' && <RacePage />}
                    {activeTab === 'badges' && <BadgesPage />}
                    {activeTab === 'versus' && <VersusPage />}
                    {activeTab === 'simulator' && <SimulatorPage />}
                    {activeTab === 'scouting' && <ScoutingReportPage />}
                    {activeTab === 'history' && <HistoryPage />}
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById("root")); root.render(<App />);
    </script>
</body>
</html>
